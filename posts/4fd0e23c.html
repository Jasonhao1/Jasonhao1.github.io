<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java面经 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java面经"><meta name="application-name" content="Java面经"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java面经"><meta property="og:url" content="http://example.com/posts/4fd0e23c.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="什么叫事务传播行为？spring支持几种事务传播行为？都是什么事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。在TransactionDefinition接口中，Spring规定了7种类型的事务传播行为。这些类型分别是：  Propagation.REQUIRE"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="John Doe"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="什么叫事务传播行为？spring支持几种事务传播行为？都是什么事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。在TransactionDefinition接口中，Spring规定了7种类型的事务传播行为。这些类型分别是：  Propagation.REQUIRE"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/posts/4fd0e23c"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: John Doe","link":"链接: ","source":"来源: Hexo","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hexo',
  title: 'Java面经',
  postAI: '',
  pageFillDescription: '什么叫事务传播行为？spring支持几种事务传播行为？都是什么, 什么是java多态, SpringAOP 代理中有几种方式分别是什么有什么特点, 什么是ASM框架, mybatis修改一个字段时部分字段为空时不修改怎么编写sql语句（动态sql）, spring两种代理jdk和cglib的区别, tcp ip 三次握手四次挥手, http和https什么区别, 对称性加密和非对称性加密, cookie和session的区别, 实现单例对象有几种方式这些方式优缺点是啥为什么懒汉要双重判断, 怎么计算两个ArrayList的并集、交集、差集, ArrayList和LinkedList区别优缺点 是不是线程安全怎么使用一个线程安全的的List, currentHashMap 怎么保证线程安全 1.7和1.8有什么区别, 怎么理解哈希冲突, 怎样理解序列化和反序列化, SrtingBuffer和StringBuilder区别, Springboot如何获得IOC容器, 什么是依赖注入, 为什么用security加jwt为什么不用session, RBAC权限模型介绍权限怎么分配的, redis都有哪些数据类型, java NIO, 什么是NIO, 为什么需要NIO?, NIO的优点, NIO的缺点, NIO的使用注意事项, 总结, java的面向对象都有哪些, java的容器都有哪些, 什么是java反射, springMVC有哪些组件, springboot的优势, springboot的核心注解文件, 什么是spring ioc, 什么是CAS, 什么是双亲委派模型 优点是什么, 一个对象垃圾回收的全过程什么叫事务传播行为支持几种事务传播行为都是什么事务传播行为是框架独有的事务增强特性他不属于的事务实际提供方数据库行为在接口中规定了种类型的事务传播行为这些类型分别是这是默认的事务传播行为如果当前方法存在事务则加入该事务如果当前方法不存在事务则创建一个新的事务如果当前方法存在事务则加入该事务如果当前方法不存在事务则使用非事务方式执行只能在存在事务的方法中被调用如果当前方法没有事务则会抛出异常如果当前方法存在事务则把当前事务挂起重新开启一个新事务不支持事务如果当前方法存在事务则把当前事务挂起不支持事务要求当前方法必须不存在事务嵌套事务如果当前方法存在事务则创建一个事务作为当前事务的嵌套事务来运行如果当前方法不存在事务则与类似创建一个新的事务这些事务传播行为可以帮助我们确定客户端和被调用端的事务边界例如多个具有事务控制的的相互调用时所形成的复杂的事务边界控制什么是多态多态是面向对象编程的重要特性之一它指的是同一个行为具有多个不同表现形式或形态的能力这种特性主要体现在子类继承父类的属性和方法后可以具有不同的数据类型或表现出不同的行为在中多态的实现主要依赖于继承接口和重写这三个概念继承使得子类能够获得父类的属性和方法接口则规定了一组方法的规范重写则允许子类重新定义这些方法以实现自己的功能特别地提供了非常方便的特性即子类对象可以直接赋给父类变量虽然看起来变量是父类型但实际执行的是子类的重写方法总的来说多态让程序设计变得更加灵活和动态大大提高了代码的可复用性和扩展性代理中有几种方式分别是什么有什么特点代理主要有两种方式动态代理和动态代理动态代理是实现接口并重写方法来创建动态代理它主要应用于目标类实现了接口的情况其核心特性在于无需修改目标对象的代码通过运行时增强目标对象来实现功能另一种是动态代理它通过继承目标类的方式利用框架生成子类来实施动态代理当目标类没有实现接口时动态代理就发挥了作用因此动态代理在应用上比动态代理更为广泛但需要注意的是由于动态代理是通过继承目标类的方式生成代理类因此如果目标类被修饰那么就无法使用动态代理了什么是框架全称字节码操作和分析框架是一个可以用于修改现有类文件或动态生成类文件的框架它提供了一种在二进制形式下直接操作字节码的方式使得开发者能够灵活地创建修改或者分析类的字节码具体来说可以在类被加载到虚拟机之前动态改变类行为这为我们在运行时改变类的结构或者行为提供了可能此外还提供了一些常见的字节码转换和分析算法这些算法可以帮助我们构建定制的复杂转换和代码分析工具总的来说框架由于其强大的功能和灵活性广泛应用于许多应用中如等帮助我们完成诸如字节码增强代码混淆等任务修改一个字段时部分字段为空时不修改怎么编写语句动态在中可以使用动态来实现部分字段为空时不修改的需求具体做法是使用和标签来构建动态语句以下是一个示例首先在接口中定义一个方法例如并传入一个对象作为参数然后在对应的映射文件中编写动态语句假设我们要更新的表名为需要更新的字段有和其中可以为空在这个示例中我们使用了标签来判断字段是否为空如果不为空则将该字段添加到子句中这样当某个字段为空时对应的语句就不会包含这个字段从而实现了部分字段为空时不修改的需求两种代理和的区别动态代理和动态代理是框架中两种常用的代理实现方式它们在实际应用中有着显著的区别首先动态代理是基于接口的代理模式如果被代理目标没有接口那么动态代理将无法工作在这种情况下会通过的反射机制生成被代理接口的新的匿名实现类并重写其中的增强方法相比之下动态代理则是利用开源包对代理对象类的文件进行加载并通过修改其字节码来生成子类以处理代理逻辑需要注意的是动态代理和动态代理在实际应用中有一些特定的使用场景例如如果要被代理的对象是一个实现类那么默认会采用动态代理来完成操作而如果被代理的对象不是一个实现类那么会强制使用来实现动态代理此外由于动态代理是通过字节码底层继承要代理类来实现的因此在被代理类被关键字修饰的情况下动态代理将会失败在日常开发中了解这两种代理方式的差异和适用场景是非常重要的基于和的动态代理在等功能中发挥着关键作用根据具体的需求和情况选择合适的代理方式能够有效地提高代码的性能和可维护性三次握手四次挥手是一种常用的网络通信协议用于在计算机网络中传输数据而三次握手和四次挥手是协议的连接建立和断开过程中的关键步骤三次握手是指在建立连接时客户端和服务器之间进行的三次通信第一次握手客户端发送一个请求连接的数据包到服务器并进入状态第二次握手服务器收到请求后如果同意连接则发送一个确认数据包回应客户端并进入状态第三次握手客户端收到服务器的回应后再发送一个确认数据包给服务器确认连接客户端和服务器都进入已连接状态可以进行数据传输四次挥手是指在断开连接时客户端和服务器之间进行的四次通信第一次挥手当客户端想要关闭连接时发送一个关闭连接的请求给服务器并进入状态第二次挥手服务器收到关闭请求后发送一个确认数据包给客户端并进入状态此时服务器仍然可以发送数据给客户端第三次挥手服务器准备关闭连接时发送一个关闭连接的请求给客户端并进入状态第四次挥手客户端收到关闭请求后发送一个确认数据包给服务器并进入状态服务器收到确认后进入状态客户端经过一段时间后也进入状态通过三次握手和四次挥手协议可以建立可靠的连接和安全地关闭连接以确保数据的可靠传输和什么区别安全性是明文传输数据在传输过程中是不加密的可能被攻击者窃听和篡改而通过使用协议对数据进行加密和认证保证了传输的安全性使得攻击者无法轻易窃听和篡改数据数据完整性在传输过程中没有提供数据的完整性校验因此数据在传输过程中可能被篡改或损坏而使用加密哈希算法来确保数据完整性一旦数据被篡改接收方可以通过校验和发现并丢弃损坏的数据端口号默认使用端口进行通信而默认使用端口进行通信这是因为需要使用加密算法进行数据加密和解密使用了特定的端口来区分普通的请求证书需要使用证书来对服务器进行身份验证确保与客户端进行安全通信的是合法的服务器证书由受信任的第三方证书机构签发用于证明服务器的合法性和可信度总的来说相对于在安全性方面提供了更好的保护适用于需要保护用户敏感信息的场景如在线支付个人账户登录等而则适用于不需要保密和完整性的一般数据传输场景对称性加密和非对称性加密对称性加密使用相同的密钥用于加密和解密数据发送方使用相同的密钥将明文加密成密文接收方使用相同的密钥将密文解密还原为明文对称性加密算法的加密速度通常比非对称性加密算法更快但密钥的传输管理需要保持机密性否则会增加安全风险非对称性加密使用了一对不同的密钥分别为公钥私钥发送方使用接收方的公钥对数据源进行加密接收方使用自己的私钥进行解密反之发送方也可以使用自己的私钥进行签名接收方使用发送方的公钥验证签名的真实性因为即使公钥泄露私钥任然保持机密对称加密和非对称加密各有优缺点通常在实际应用中会结合使用一种常见的做法是使用非对称加密算法来安全地传输对称加密所需的密钥发送方用接收方的公钥对密钥进行加密然后将加密后的密钥发送给接收方接收方使用自己的私钥解密得到对称密钥接下来使用对称加密算法对数据进行加密和解密这种组合的方式可以实现高效的对称加密和安全的密钥交换同时保证了数据的保密性和完整性常见的实际应用中使用的加密协议如就采用了对称加密和非对称加密的结合和的区别存储位置是存储在客户端浏览器中的小型文本文件每次请求时都会包含在头中发送到服务器而存储在服务器端通常存储在内存中或者持久化到数据库或文件系统中数据安全性中的数据可以被客户端修改和篡改因此不适合存储敏感信息而存储在服务器端只有存储在客户端的中所有的数据处理都在服务端进行相对更安全存储容量的存储容量有限通常最大为几而的存储容量通常没有明确限制可根据服务器的配置和处理能力进行调整生命周期可以设置过期时间可以是会话级别关闭流浏览器即失效或具体的日期和时间而可以设置超时时间一旦超过时间没有活动服务器会自动销毁该跨页面传递可以在不同页面之间共享并在每次请求时发送到服务器而通常通过在中存储一个通过该在服务器端找到相应的数据总的来说适合存储一些较小的非敏感数据可以实现跨页面的状态跟踪而适合存储敏感信息和大量数据可以实现更安全的用户会话管理在实际开发中和可以结合使用来满足不同场景的需求实现单例对象有几种方式这些方式优缺点是啥为什么懒汉要双重判断实现单例对象的方式主要有饿汉式和懒汉式两种饿汉式是在类被加载的时候就创建了单例对象所以饿汉式的优点是线程安全的获取单例对象时不需要加锁然而这种方式的缺点是不管是否需要对象都会被创建可能会造成不必要的资源浪费相较于饿汉式懒汉式在第一次调用方法时才创建对象为了解决懒汉式在多线程环境下可能创建多个实例的问题需要采用双重判断锁定来确保线程安全这样既实现了延时加载又保证了线程安全性但同时也使得代码相对复杂综上饿汉式适合在对象创建成本较低且对性能要求较高的场景下使用而懒汉式适合在对象创建成本较高且可能需要延时加载以节省资源的场景下使用具体选择哪种方式需要根据实际情况和需求来判断怎么计算两个的并集交集差集要计算两个的并集交集和差集可以使用中的计算交集计算差集和计算并集方法和区别优缺点是不是线程安全怎么使用一个线程安全的的是基于动态数组实现的它允许随机访问任意位置的元素但插入和删除元素时需要移动大量元素性能较低是基于双向链表实现的插入和删除元素时只需要修改指针性能较高但随机访问元素时需要遍历链表性能较低的优点随机访问性能好查询速度快缺点插入和删除元素时性能较差的优点插入和删除元素时性能较好缺点随机访问元素时性能较差和都不是线程安全的如果需要在多线程环境下使用可以使用线程安全的实现类如或方法返回的同步这些线程安全的在多线程环境下可以保证数据的一致性和安全性怎么保证线程安全和有什么区别是线程安全的它采用了一种分段锁技术在中有一个数组每个对象都有一个链表当进行操作时会将数据插入到对应的中并锁定该这样其他线程就无法对该中的链表进行操作从而保证了线程安全在和版本中这种实现方式有所不同在版本中对整个加锁而在版本中锁的粒度降低到首节点这种改变使得在数据比较多的情况下访问速度得到了提升因为现在不需要遍历整个链表另外在版本的实现中还采用了来保证并发安全此外对于扩容操作也是线程安全的在中一旦初始化后数组就不会再进行扩容而是可以扩容的且该扩容操作是在方法中进行的由于操作已经被使用锁保证了线程安全所以也保证了扩容的线程安全性怎么理解哈希冲突哈希冲突是指在哈希表中不同的键可能会被哈希函数计算出相同的哈希值即地址这种现象称为哈希冲突这是由于哈希函数是将任意长度的输入转化为固定长度的输出转化过程中有可能会出现碰撞虽然哈希冲突是无法避免的但有多种方法可以解决这个问题其中常见的解决策略包括开放定址法线性探测法平方探测法再哈希法链地址法和建立公共溢出区等例如链地址法就是在每个位桶实现的时候采用链表或者从开始采用链表红黑树的数据结构来存储发生哈希冲突的输入域的关键字怎样理解序列化和反序列化序列化是将内存中的对象转化为自己序列的过程以便将其存储在磁盘文件或者通过网络进行传输反序列化则是将这个字节序列再次转化回对象的过程语言提供了一套丰富的来实现对象的序列化和反序列化当一个类实现了接口他就被序列化在进行序列化时会使用一个叫做的字段来保证反序列化时类的版本的正确性序列化的主要应用包括对象的持久化和网络传输持久化是指将对象转化为字节序列并存储在硬盘上这样即使停止运行对象的信息也不会丢失可以在需要的时候通过反序列化恢复对象网络传输则涉及到在不同计算机之间的信息交换由于直接传输对象是不可能的因此需要先将对象序列化为字节流然后在网络上传输接收方收到后进行反序列化恢复为对象和区别和都是中用于处理可变的字符串的类它们之间的主要区别在于线程安全性和可变性具体来说类的实现不是线程安全的因此在单线程环境下它的性能通常更高而是线程安全的由于其采用了关键字实现这会带来一定的性能开销另外与类不同的是和类的对象能够被多次修改并且不产生新的未使用对象每次对或的操作都会直接在其本身上进行而不是生成新的对象总的来说如果你在单线程环境下进行字符串操作并且对性能有较高要求那么建议使用如果你的应用场景需要在多线程环境下保证线程安全那么可以考虑使用如何获得容器在项目中获取容器的方式主要有两种其中一种方法是在项目中都会存在一个名为的启动类我们可以通过调用该类的方法来启动容器另一种方式是直接从容器中获取实例在某些特殊情况下例如在拦截器中获取实例时需要实现某个功能但该功能必须借助于容器才能实现此时就必须让该先获取容器什么是依赖注入依赖注入简称是一种设计模式也是框架的核心概念之一其主要作用是去除类之间的依赖关系实现松耦合以便于开发和测试具体来说依赖注入就是不通过的方式在类内部创建依赖类的对象而是将依赖的类对象在外部创建好之后通过构造函数函数参数等方式传递或注入给类来使用此外依赖注入是控制反转简称思想的具体实现方式控制反转是一种程序设计思想而依赖注入则是其最典型的实践方法在控制反转中由第三方通常称作容器来控制依赖把依赖通过构造函数属性或者工厂模式等方法注入到类内这样就极大程度的对类和其依赖进行了解耦为什么用加为什么不用扩展性和是基于协议的随着技术的不断发展如等技术的出现协议已经无法满足一些复杂的业务需求新的技术如等可以更安全地存储用户信息并克服了传统技术的一些缺点管理方式理论上用于无状态的请求其用户管理也只是依赖本身而已在它的中加入过期时间无需增加额外的管理只有自动过期的方式而因为存储在服务器端因此其管理方案就有很多而且大多都很成熟跨平台可以实现跨平台使用这是因为它的认证信息是存储在客户端的而不是像一样存储在服务器端无状态与不同不需要在服务器端存储状态信息这降低了服务器的压力并提高了系统的可扩展性安全性可以将用户信息加密后存储在客户端提高了安全性如果需要访问敏感信息只需要解密部分数据即可而不需要像一样将整个用户信息暴露给客户端传统的基于的方式是有状态认证用户登录成功将用户的身份信息存储在服务端这样加大了服务端的存储压力并且这种方式不适合在分布式系统中应用当用户访问应用服务每个应用服务都会去服务器查看信息如果中没有该用户则说明用户没有登录此时就会重新认证而解决这个问题的方法是复制黏贴如果是基于令牌技术在分布式系统中实现认证则服务端不用存储可以将用户身份信息存储在令牌中用户认证通过后认证服务颁发令牌给用户用户将令牌存储在客户端去访问应用服务时携带令牌去访问服务端从解析出用户信息这个过程就是无状态认证权限模型介绍权限怎么分配的基于角色的访问控制系统可扩展性差基于资源的访问控制系统设计时定义好查询工资的权限标识即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码系统可扩展性强都有哪些数据类型支持的主要数据类型有五种字符串哈希列表集合和有序集合其中是最基本的类型每个对应一个并且类型是二进制安全的意味着它可以包含任何数据如图片或序列化的对象这种数据类型的值最大能存储在实际业务场景中类型常用来缓存结构体信息也经常被用来存储用户的信息缓存静态文件等而类型则是一种键值对的集合适用于存储对象是一个简单的字符串列表按插入顺序排序适用于消息队列关注列表等场景是一个无序且不重复的字符串集合适用于抽奖社交标签等功能有序集合和类似但每个元素都会关联一个类型的分数用于排序适用于排行榜等场景什么是是提供的一种非阻塞模型它在中引入与传统的模型相比提供了更高效更灵活的操作方式为什么需要传统的模型使用阻塞式在进行读写操作时会导致线程被阻塞直到数据准备好或者写入完成这种模型对于并发处理能力较弱当有大量连接同时请求时每个连接都需要一个独立的线程来处理造成资源浪费和性能下降而采用了事件驱动的方式通过轮询注册的通道只有在通道真正有读写事件发生时才会进行处理避免了线程被阻塞的情况提高了系统的并发处理能力的实现原理的核心组件包括和类似于传统中的流可以通过进行数据的读取和写入常见的类型有等缓冲区用于存储数据在中所有的数据都是通过进行读写的常见的类型有等选择器用于监听多个的事件通过可以实现单线程处理多个通道的读写操作的工作原理如下创建一个并将其注册到需要监听的上当有数据准备好时会轮询已注册的发现有事件发生的后进行处理根据不同的事件类型读写连接接收使用对应的方法进行处理的优点高并发性采用了事件驱动的方式可以使用单线程处理多个通道的读写操作提高系统的并发处理能力非阻塞式模型中的通道是非阻塞的不会因为某个通道的读写操作而导致线程被阻塞提高了系统的响应速度和吞吐量内存管理优化使用了直接内存缓冲区可以减少数据在堆和操作系统之间的拷贝次数提高了性能的缺点复杂性较高相比传统的阻塞式模型的编程模型更加复杂需要处理事件驱动多路复用等概念对编程人员要求较高由于的复杂性对编程人员的技术要求较高需要熟悉相关的和底层原理的使用注意事项需要合理设置缓冲区大小过小的缓冲区可能导致频繁的读写操作影响性能过大的缓冲区可能造成资源浪费注意正确释放资源在使用完和后需要及时关闭并释放资源避免出现资源泄露问题谨慎处理异常情况中的异常处理相对复杂需要仔细处理各种异常情况以保证程序的稳定性和可靠性总结是一种非阻塞模型通过事件驱动和选择器机制实现高效的操作它具有高并发性非阻塞式和内存管理优化等优点但也存在复杂性较高和对编程人员要求较高的缺点在使用时需要注意合理设置缓冲区大小正确释放资源和谨慎处理异常情况的面向对象都有哪些面向对象编程是一种编程范式它包括三大基本特征封装继承和多态封装是指将数据和方法绑定在一起形成一个类从而隐藏了类的实现细节继承是指从已有的类派生出新的类新的类继承了原有类的属性和方法并可以添加新的属性和方法多态是指同一种类型的对象在不同的情况下具有不同的行为在中面向对象的核心概念包括对象类和实例对象是类的一个实例有状态和行为例如一条狗是一个对象它的状态有颜色名字品种行为有摇尾巴叫吃等类是一个模板它描述一类对象的行为和状态每个对象都是某个类的实例它们可以拥有相同的属性和方法另外抽象接口方法和重载也是面向对象编程的重要概念抽象是指将一类对象的共同特征总结出来构造类的过程它忽略了对象之间的差异接口定义了一种规范规定了实现此接口的类必须提供哪些方法方法是一段具有特定功能的代码块可以接受参数并返回结果重载是指在一个类中允许存在一个以上同名的方法但这些方法的参数数量或类型必须不同的容器都有哪些的容器主要包括以下几种类型数组这是最基础的容器类型它能够容纳固定数量的对象集合这是一种动态的容器类型可以容纳任意数量的对象其中一些常用的集合类型包括和例如是一个有序的集合允许元素的重复并提供了诸如添加元素移除元素获取表的大小获取元素等方法而是一个不允许元素重复且不保持顺序的集合这是一种关联数组存储的是键值对每个键都与一个值相关联这样可以方便地通过键查找值字符串和这两种类型的对象主要用于处理和操作字符串其中类的对象用于处理长度可变的字符串而类的对象则用于处理内容不可变的字符串什么是反射反射是一种强大的编程技术它允许运行中的程序访问检查和修改一个类的属性和方法具体来说反射使程序员能够在运行时知道任意一个类的所有属性和方法无论这个类是在什么时候加载的此外反射还使得对于任意一个对象都能够调用它的任意方法和属性甚至可以在运行时改变它的属性反射机制的核心在于程序运行时动态加载类以及获取该类的详细信息包括类的属性和方法这一过程依赖于得到的对象通过这个对象程序能够获取到类的各种信息并进行反编译等操作反射机制提供了许多功能包括但不限于判断运行时任意对象所属的类创建运行时任意类的对象判断运行时任意类所具有的成员变量和方法以及在运行时调用任意对象的方法这些特性使得被视为具有动态性质的一种语言总的来说反射技术让程序在运行时可以获取类的信息操作类对象动态调用方法创建类实例等从而在很大程度上增强了程序的灵活性和可扩展性有哪些组件的组件有以下几种前端控制器处理器映射器处理器适配器拦截器语言环境处理器等其中前端控制器是请求的入口处理器映射器负责让请求和控制器建立一一对应的关联处理器适配器运用了设计模式中的适配器模式统一调用不同的拦截器可以在请求处理之前或之后进行一些操作语言环境处理器则用于解析客户端请求的语言环境的优势是框架的一种扩展其优势主要体现在以下几个方面首先可以快速构建独立的应用它依靠大量的注解实现自动化配置开发者只需添加相应的场景依赖就会自动进行配置从而无需额外手动添加配置就可以快速构建出一个独立的应用其次可以直接嵌入和服务器无需部署文件此外还提供了诸如自动依赖自动配置以及第三方功能生产级别的监控健康检查以及外部优化配置等一系列特性极大地简化了开发部署效率最后与云计算的天然集成使其更适应现代化的软件开发和部署简化依赖比如我们要创建一个项目使用的朋友都知道在使用的时候需要在文件中添加多个依赖而则会帮助开发着快速启动一个容器在中我们只需要在文件中添加如下一个依赖即可我们点击进入该依赖后可以看到这个已经包含了多个依赖包括之前在工程中需要导入的依赖我们看一下其中的一部分如下省略其他依赖由此可以看出大大简化了我们的编码我们不用一个个导入依赖直接一个依赖即可简化配置虽然使轻量级框架但由于其繁琐的配置一度被人认为是配置地狱各种配置会让人眼花缭乱而且配置多的话如果出错了也很难找出原因更多的是采用的方式对进行配置举个例子我新建一个类但是我不用注解也就是说它是个普通的类那么我们如何使它也成为一个让去管理呢只需要和两个注解即可如下表示该类是个配置类表示该方法返回一个这样就把作为让去管理了在其他地方我们如果需要使用该和原来一样直接使用注解注入进来即可使用非常方便另外部署配置方面原来有多个和配置在中只需要个即可简化部署在使用时项目部署时需要我们在服务器上部署然后把项目打成包扔到里在使用后我们不需要在服务器上去部署因为内嵌了我们只需要将项目打成包使用一键式启动项目另外也降低对运行环境的基本要求环境变量中有即可简化监控我们可以引入依赖直接使用方式来获取进程的运行期性能参数从而达到监控的目的比较方便但是只是个微框架没有提供相应的服务发现与注册的配套功能没有外围监控集成方案没有外围安全管理方案所以在微服务架构中还需要来配合一起使用的核心注解文件的核心注解是这个注解通常用在启动类上主要的功能是让自动为程序进行必要的配置它主要由以下三个注解组成和是一个组合注解其中包含了这使得它可以替代配置文件所有能在配置文件里完成的事情都可以通过这个注解所在的类来进行注册是用来打开自动配置的功能可以根据下的包自动配置例如数据源自动配置等如果需要关闭某个自动配置的选项可以使用类似以下的代码是框架中的一个注解它会扫描指定包路径下的所有类并将这些类注册为这样就可以在其他地方使用这些了此外还提供了两个全局配置文件和这两个文件可以对一些默认配置值进行修改这两个文件一般存放在项目的目录下什么是是一种让服务消费者不直接依赖于服务提供者的组件设计方式是一种减少类与类之间依赖的设计原则它将对象的创建权力反转给框架通过在容器中创建对象实现了对象之间的解耦在传统的开发中一个类想要使用另一个类的方法就必须在这个类中创建这个类的对象这样可能会导致程序出现耦合性问题而通过将对象的创建和管理交给容器使得对象之间的依赖关系由容器来维护从而降低了程序的耦合性提高了程序的可维护性和可扩展性什么是是的缩写即比较并交换它是一种多线程同步的算法用于实现多线程环境下的原子操作在中操作数值的时候会先比较当前内存中的值是否与期望值相等如果相等则将新值写入内存否则不做任何操作操作是一种乐观锁它不需要加锁因此可以提高并发性能常用于实现线程安全的数据结构如原子类和自旋锁等什么是双亲委派模型优点是什么双亲委派模型是中的一种类加载机制它指的是类加载器在加载一个类时先将该请求委派给父类加载器去完成如果父类加载器还存在父类加载器则继续向上委派直到委派到最顶层的启动类加载器为止如果父类加载器无法完成类的加载请求子加载器才会尝试自己去加载这种机制可以避免重复加载保证了程序的稳定性和安全性双亲委派模型的优点主要有两个避免类的重复加载由于类加载器在加载类时会先委派给父类加载器因此可以避免同一个类被多次加载从而节省了内存空间提高安全性由于父类加载器在委派给子类加载器时会先检查该类是否已经被加载过如果已经被加载过则直接返回已经加载的类从而避免了恶意类的加载提高了程序的安全性一个对象垃圾回收的全过程一个对象从加载到再到被清除它的过程可以分为几个阶段类加载对象实例化对象使用和垃圾回收新创建的对象首先会被分配到区随着程序的运行区可能会满或者快满这时就会进行一次也就是清理过程在这个过程中不被引用的对象会被直接清除掉仍然有引用的对象但如果它们的存在时间较长则会被移动到区当区再次快满的时候会再进行一次清理这次清理会涉及到区和区存活的对象会被放入区而区则被清空这个过程并不是一次性的而是会在运行时持续发生每次垃圾回收后区会继续提供堆内存供新的对象存放这就是一个对象从创建到被垃圾回收的全过程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 09:17:04',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Hexo</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Java面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-01T01:02:48.000Z" title="发表于 2023-12-01 09:02:48">2023-12-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-01T01:17:04.581Z" title="更新于 2023-12-01 09:17:04">2023-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/posts/4fd0e23c.html"><header><h1 id="CrawlerTitle" itemprop="name headline">Java面经</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">John Doe</span><time itemprop="dateCreated datePublished" datetime="2023-12-01T01:02:48.000Z" title="发表于 2023-12-01 09:02:48">2023-12-01</time><time itemprop="dateCreated datePublished" datetime="2023-12-01T01:17:04.581Z" title="更新于 2023-12-01 09:17:04">2023-12-01</time></header><h1 id="什么叫事务传播行为？spring支持几种事务传播行为？都是什么"><a href="#什么叫事务传播行为？spring支持几种事务传播行为？都是什么" class="headerlink" title="什么叫事务传播行为？spring支持几种事务传播行为？都是什么"></a>什么叫事务传播行为？spring支持几种事务传播行为？都是什么</h1><p>事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。在TransactionDefinition接口中，Spring规定了7种类型的事务传播行为。这些类型分别是：</p>
<ol>
<li>Propagation.REQUIRED：这是spring默认的事务传播行为。如果当前方法存在事务，则加入该事务；如果当前方法不存在事务，则创建一个新的事务。</li>
<li>Propagation.SUPPORTS：如果当前方法存在事务，则加入该事务；如果当前方法不存在事务，则使用非事务方式执行。</li>
<li>Propagation.MANDATORY：只能在存在事务的方法中被调用。如果当前方法没有事务，则会抛出异常。</li>
<li>Propagation.REQUIRES_NEW：如果当前方法存在事务，则把当前事务挂起，重新开启一个新事务。</li>
<li>Propagation.NOT_SUPPORTED：不支持事务，如果当前方法存在事务，则把当前事务挂起。</li>
<li>Propagation.NEVER：不支持事务，要求当前方法必须不存在事务。</li>
<li>Propagation.NESTED：嵌套事务，如果当前方法存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前方法不存在事务，则与Propagation.REQUIRED类似，创建一个新的事务。</li>
</ol>
<p>这些事务传播行为可以帮助我们确定客户端和被调用端的事务边界，例如多个具有事务控制的service的相互调用时所形成的复杂的事务边界控制。</p>
<h1 id="什么是java多态"><a href="#什么是java多态" class="headerlink" title="什么是java多态"></a>什么是java多态</h1><p>Java多态是面向对象编程的重要特性之一，它指的是同一个行为具有多个不同表现形式或形态的能力。这种特性主要体现在子类继承父类的属性和方法后，可以具有不同的数据类型或表现出不同的行为。</p>
<p>在Java中，多态的实现主要依赖于继承、接口和重写这三个概念。继承使得子类能够获得父类的属性和方法，接口则规定了一组方法的规范，重写则允许子类重新定义这些方法以实现自己的功能。特别地，Java提供了非常方便的特性，即子类对象可以直接赋给父类变量，虽然看起来变量是父类型，但实际执行的是子类的重写方法。</p>
<p>总的来说，Java多态让程序设计变得更加灵活和动态，大大提高了代码的可复用性和扩展性。</p>
<h1 id="SpringAOP-代理中有几种方式，分别是什么，有什么特点"><a href="#SpringAOP-代理中有几种方式，分别是什么，有什么特点" class="headerlink" title="SpringAOP 代理中有几种方式，分别是什么，有什么特点"></a>SpringAOP 代理中有几种方式，分别是什么，有什么特点</h1><p>Spring AOP代理主要有两种方式：JDK动态代理和CGLib动态代理。</p>
<p>JDK动态代理是实现InvocationHandlet接口，并重写invoke方法来创建动态代理。它主要应用于目标类实现了接口的情况。其核心特性在于无需修改目标对象的代码，通过运行时增强目标对象来实现AOP功能。</p>
<p>另一种是CGLib动态代理，它通过继承目标类的方式，利用ASM框架生成子类来实施动态代理。当目标类没有实现接口时，CGLib动态代理就发挥了作用。因此，CGLib动态代理在应用上比JDK动态代理更为广泛，但需要注意的是，由于CGLib动态代理是通过继承目标类的方式生成代理类，因此如果目标类被final修饰，那么就无法使用CGLib动态代理了。</p>
<h1 id="什么是ASM框架"><a href="#什么是ASM框架" class="headerlink" title="什么是ASM框架"></a>什么是ASM框架</h1><p>ASM，全称Java字节码操作和分析框架，是一个可以用于修改现有类文件或动态生成类文件的框架。它提供了一种在二进制形式下直接操作Java字节码的方式，使得开发者能够灵活地创建、修改或者分析Java类的字节码。</p>
<p>具体来说，ASM可以在类被加载到Java虚拟机之前动态改变类行为，这为我们在运行时改变类的结构或者行为提供了可能。此外，ASM还提供了一些常见的字节码转换和分析算法，这些算法可以帮助我们构建定制的复杂转换和代码分析工具。</p>
<p>总的来说，ASM框架由于其强大的功能和灵活性，广泛应用于许多Java应用中，如Spring AOP、Hibernate等，帮助我们完成诸如字节码增强、代码混淆等任务。</p>
<h1 id="mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）"><a href="#mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）" class="headerlink" title="mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）"></a>mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）</h1><p>在MyBatis中，可以使用动态SQL来实现部分字段为空时不修改的需求。具体做法是使用<code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>和<code>&lt;otherwise&gt;</code>标签来构建动态SQL语句。以下是一个示例：</p>
<ol>
<li>首先，在Mapper接口中定义一个方法，例如<code>updateUser</code>，并传入一个<code>User</code>对象作为参数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，在对应的XML映射文件中编写动态SQL语句。假设我们要更新的表名为<code>user</code>，需要更新的字段有<code>name</code>、<code>age</code>和<code>email</code>，其中<code>email</code>可以为空。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name = #&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">                age = #&#123;age&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了<code>&lt;if&gt;</code>标签来判断字段是否为空，如果不为空，则将该字段添加到<code>SET</code>子句中。这样，当某个字段为空时，对应的SQL语句就不会包含这个字段，从而实现了部分字段为空时不修改的需求。</p>
<h1 id="spring两种代理jdk和cglib的区别"><a href="#spring两种代理jdk和cglib的区别" class="headerlink" title="spring两种代理jdk和cglib的区别"></a>spring两种代理jdk和cglib的区别</h1><p>JDK动态代理和CGLib动态代理是Spring框架中两种常用的代理实现方式，它们在实际应用中有着显著的区别。首先，JDK动态代理是基于接口的代理模式，如果被代理目标没有接口，那么JDK动态代理将无法工作。在这种情况下，Spring会通过Java的反射机制生成被代理接口的新的匿名实现类，并重写其中的增强方法。相比之下，CGLib动态代理则是利用ASM开源包，对代理对象类的class文件进行加载，并通过修改其字节码来生成子类以处理代理逻辑。</p>
<p>需要注意的是，JDK动态代理和CGLib动态代理在实际应用中有一些特定的使用场景。例如，如果要被代理的对象是一个实现类，那么Spring默认会采用JDK动态代理来完成操作。而如果被代理的对象不是一个实现类，那么Spring会强制使用CGLib来实现动态代理。此外，由于CGLib动态代理是通过字节码底层继承要代理类来实现的，因此在被代理类被final关键字修饰的情况下，CGLib动态代理将会失败。</p>
<p>在日常开发中，了解这两种代理方式的差异和适用场景是非常重要的。基于JDK和CGLib的动态代理在Spring AOP等功能中发挥着关键作用，根据具体的需求和情况选择合适的代理方式能够有效地提高代码的性能和可维护性。</p>
<h1 id="tcp-ip-三次握手四次挥手"><a href="#tcp-ip-三次握手四次挥手" class="headerlink" title="tcp ip 三次握手四次挥手"></a>tcp ip 三次握手四次挥手</h1><p>TCP&#x2F;IP是一种常用的网络通信协议，用于在计算机网络中传输数据。而三次握手和四次挥手是TCP协议的连接建立和断开过程中的关键步骤。</p>
<ol>
<li><p>三次握手是指在建立TCP连接时，客户端和服务器之间进行的三次通信。	</p>
<ul>
<li>第一次握手：客户端发送一个请求连接的数据包（SYN）到服务器，并进入SYN_SENT状态。</li>
<li>第二次握手：服务器收到请求后，如果同意连接，则发送一个确认数据包（SYN+ACK）回应客户端，并进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的回应后，再发送一个确认数据包（ACK）给服务器，确认连接。客户端和服务器都进入已连接状态（ESTABLISHED），可以进行数据传输。</li>
</ul>
</li>
<li><p>四次挥手是指在断开TCP连接时，客户端和服务器之间进行的四次通信。</p>
<ul>
<li><p>第一次挥手：当客户端想要关闭连接时，发送一个“关闭连接”的请求给服务器，并进入FIN_WAIT1状态。</p>
</li>
<li><p>第二次挥手：服务器收到关闭请求后，发送一个确认数据包（ACK）给客户端，并进入CLOSE_WAIT状态。此时，服务器仍然可以发送数据给客户端。</p>
</li>
<li><p>第三次挥手：服务器准备关闭连接时，发送一个“关闭连接”的请求给客户端，并进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：客户端收到关闭请求后，发送一个确认数据包（ACK）给服务器，并进入TIME_WAIT状态。服务器收到确认后，进入CLOSED状态，客户端经过一段时间后也进入CLOSED状态。</p>
</li>
</ul>
</li>
</ol>
<p>通过三次握手和四次挥手，TCP协议可以建立可靠的连接和安全地关闭连接，以确保数据的可靠传输。</p>
<h1 id="http和https什么区别"><a href="#http和https什么区别" class="headerlink" title="http和https什么区别"></a>http和https什么区别</h1><ol>
<li>安全性：HTTP是明文传输，数据在传输过程中是不加密的，可能被攻击者窃听和篡改。而HTTPS通过使用 SSL&#x2F;TLS 协议对数据进行加密和认证，保证了传输的安全性，使得攻击者无法轻易窃听和篡改数据。</li>
<li>数据完整性：HTTP在传输过程中没有提供数据的完整性校验，因此数据在传输过程中可能被篡改或损坏。而HTTPS使用加密哈希算法来确保数据完整性，一旦数据被篡改，接收方可以通过校验和发现并丢弃损坏的数据。</li>
<li>端口号：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口进行通信。这是因为HTTPS需要使用加密算法进行数据加密和解密，使用了特定的端口来区分普通的HTTP请求。</li>
<li>证书：HTTPS需要使用证书来对服务器进行身份验证，确保与客户端进行安全通信的是合法的服务器。证书由受信任的第三方证书机构（CA）签发，用于证明服务器的合法性和可信度。</li>
</ol>
<p>总的来说，HTTPS相对于HTTP在安全性方面提供了更好的保护，适用于需要保护用户敏感信息的场景，如在线支付、个人账户登录等。而HTTP则适用于不需要保密和完整性的一般数据传输场景。</p>
<h1 id="对称性加密和非对称性加密"><a href="#对称性加密和非对称性加密" class="headerlink" title="对称性加密和非对称性加密"></a>对称性加密和非对称性加密</h1><ul>
<li>对称性加密使用相同的密钥用于加密和解密数据。发送方使用相同的密钥将明文加密成密文，接收方使用相同的密钥将密文解密还原为明文。对称性加密算法的加密速度通常比非对称性加密算法更快，但密钥的传输管理需要保持机密性，否则会增加安全风险。</li>
<li>非对称性加密使用了一对不同的密钥（分别为公钥，私钥）。发送方使用接收方的公钥对数据源进行加密，接收方使用自己的私钥进行解密。反之，发送方也可以使用自己的私钥进行签名，接收方使用发送方的公钥验证签名的真实性，因为即使公钥泄露，私钥任然保持机密。</li>
<li>对称加密和非对称加密各有优缺点，通常在实际应用中会结合使用。</li>
<li>一种常见的做法是，使用非对称加密算法来安全地传输对称加密所需的密钥。发送方用接收方的公钥对密钥进行加密，然后将加密后的密钥发送给接收方。接收方使用自己的私钥解密得到对称密钥，接下来使用对称加密算法对数据进行加密和解密。</li>
<li>这种组合的方式可以实现高效的对称加密和安全的密钥交换，同时保证了数据的保密性和完整性。常见的实际应用中使用的加密协议，如SSL&#x2F;TLS，就采用了对称加密和非对称加密的结合。</li>
</ul>
<h1 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h1><ol>
<li>存储位置：cookie是存储在客户端（浏览器）中的小型文本文件，每次请求时都会包含在HTTP头中发送到服务器。而session存储在服务器端，通常存储在内存中或者持久化到数据库或文件系统中。</li>
<li>数据安全性：cookie中的数据可以被客户端修改和篡改，因此不适合存储敏感信息。而session存储在服务器端，只有sessionID存储在客户端的cookie中，所有的数据处理都在服务端进行，相对更安全。</li>
<li>存储容量：cookie的存储容量有限，通常最大为几kb，而session的存储容量通常没有明确限制，可根据服务器的配置和处理能力进行调整。</li>
<li>生命周期：cookie可以设置过期时间，可以是会话级别（关闭流浏览器即失效）或具体的日期和时间。而session可以设置超时时间，一旦超过时间没有活动，服务器会自动销毁该session。</li>
<li>跨页面传递：cookie可以在不同页面之间共享，并在每次请求时发送到服务器。而session通常通过在cookie中存储一个sessionID,通过该id在服务器端找到相应的session数据。</li>
</ol>
<p>总的来说，cookie适合存储一些较小的非敏感数据，可以实现跨页面的状态跟踪。而session适合存储敏感信息和大量数据，可以实现更安全的用户会话管理。在实际开发中，cookie和session可以结合使用来满足不同场景的需求。</p>
<h1 id="实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断"><a href="#实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断" class="headerlink" title="实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断"></a>实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断</h1><ul>
<li><p>实现单例对象的方式主要有饿汉式和懒汉式两种。饿汉式是在类被加载的时候就创建了单例对象，所以饿汉式的优点是线程安全的，获取单例对象时不需要加锁。然而，这种方式的缺点是不管是否需要，对象都会被创建，可能会造成不必要的资源浪费。</p>
</li>
<li><p>相较于饿汉式，懒汉式在第一次调用getInstance方法时才创建对象。为了解决懒汉式在多线程环境下可能创建多个实例的问题，需要采用双重判断锁定（double-checked locking）来确保线程安全。这样既实现了延时加载，又保证了线程安全性，但同时也使得代码相对复杂。</p>
</li>
</ul>
<p>综上，饿汉式适合在对象创建成本较低，且对性能要求较高的场景下使用；而懒汉式适合在对象创建成本较高，且可能需要延时加载以节省资源的场景下使用。具体选择哪种方式，需要根据实际情况和需求来判断。</p>
<h1 id="怎么计算两个ArrayList的并集、交集、差集"><a href="#怎么计算两个ArrayList的并集、交集、差集" class="headerlink" title="怎么计算两个ArrayList的并集、交集、差集"></a>怎么计算两个ArrayList的并集、交集、差集</h1><p>要计算两个ArrayList的并集、交集和差集，可以使用Java中的<code>retainAll()</code>、（<em>计算交集</em>）；<code>removeAll()</code>（<em>计算差集</em>）和<code>addAll()</code>（<em>计算并集</em>）方法。</p>
<h1 id="ArrayList和LinkedList区别，优缺点-是不是线程安全，怎么使用一个线程安全的的List"><a href="#ArrayList和LinkedList区别，优缺点-是不是线程安全，怎么使用一个线程安全的的List" class="headerlink" title="ArrayList和LinkedList区别，优缺点 是不是线程安全，怎么使用一个线程安全的的List"></a>ArrayList和LinkedList区别，优缺点 是不是线程安全，怎么使用一个线程安全的的List</h1><ul>
<li><p>ArrayList是基于动态数组实现的，它允许随机访问任意位置的元素，但插入和删除元素时需要移动大量元素，性能较低。LinkedList是基于双向链表实现的，插入和删除元素时只需要修改指针，性能较高，但随机访问元素时需要遍历链表，性能较低。</p>
</li>
<li><p>ArrayList的优点：随机访问性能好，查询速度快；缺点：插入和删除元素时性能较差。</p>
</li>
<li><p>LinkedList的优点：插入和删除元素时性能较好；缺点：随机访问元素时性能较差。</p>
</li>
<li><p>ArrayList和LinkedList都不是线程安全的，如果需要在多线程环境下使用List，可以使用线程安全的List实现类，如Vector或Collections.synchronizedList()方法返回的同步List。这些线程安全的List在多线程环境下可以保证数据的一致性和安全性。</p>
</li>
</ul>
<h1 id="currentHashMap-怎么保证线程安全-1-7和1-8有什么区别"><a href="#currentHashMap-怎么保证线程安全-1-7和1-8有什么区别" class="headerlink" title="currentHashMap 怎么保证线程安全 1.7和1.8有什么区别"></a>currentHashMap 怎么保证线程安全 1.7和1.8有什么区别</h1><ul>
<li><p>ConcurrentHashMap是线程安全的，它采用了一种分段锁技术。在ConcurrentHashMap中，有一个Segment数组，每个Segment对象都有一个HashEntry链表。当进行put操作时，会将数据插入到对应的Segment中，并锁定该Segment。这样其他线程就无法对该Segment中的HashEntry链表进行操作，从而保证了线程安全。</p>
</li>
<li><p>在JDK 1.7和1.8版本中，这种实现方式有所不同。在1.7版本中，对整个Segment加锁，而在1.8版本中，锁的粒度降低到HashEntry（首节点）。这种改变使得在数据比较多的情况下访问速度得到了提升，因为现在不需要遍历整个链表。另外，在1.8版本的实现中，还采用了Node + CAS + Synchronized来保证并发安全。</p>
</li>
</ul>
<p>此外，对于扩容操作也是线程安全的。在JDK1.7中，一旦初始化后Segment数组就不会再进行扩容，而HashEntry是可以扩容的，且该扩容操作是在put方法中进行的，由于put操作已经被使用锁保证了线程安全，所以也保证了扩容的线程安全性。</p>
<h1 id="怎么理解哈希冲突"><a href="#怎么理解哈希冲突" class="headerlink" title="怎么理解哈希冲突"></a>怎么理解哈希冲突</h1><p>哈希冲突是指在哈希表中，不同的键（Key）可能会被哈希函数计算出相同的哈希值，即地址，这种现象称为哈希冲突。这是由于哈希函数是将任意长度的输入转化为固定长度的输出，转化过程中有可能会出现碰撞。</p>
<p>虽然哈希冲突是无法避免的，但有多种方法可以解决这个问题。其中常见的解决策略包括开放定址法、线性探测法、平方探测法、再哈希法、链地址法和建立公共溢出区等。例如，链地址法就是在每个位桶实现的时候，采用链表（或者从JDK 1.8开始，采用链表+红黑树）的数据结构来存储发生哈希冲突的输入域的关键字。</p>
<h1 id="怎样理解序列化和反序列化"><a href="#怎样理解序列化和反序列化" class="headerlink" title="怎样理解序列化和反序列化"></a>怎样理解序列化和反序列化</h1><p>序列化是将内存中的对象转化为自己序列的过程，以便将其存储在磁盘文件或者通过网络进行传输。反序列化则是将这个字节序列再次转化回对象的过程。</p>
<ul>
<li>java语言提供了一套丰富的API来实现对象的序列化和反序列化。当一个类实现了Serializable接口，他就被序列化。在进行序列化时，java会使用一个叫做serialVersionUID的字段来保证反序列化时类的版本的正确性。</li>
<li>序列化的主要应用包括对象的持久化和网络传输。持久化是指将对象转化为字节序列并存储在硬盘上，这样即使JVM停止运行，对象的信息也不会丢失，可以在需要的时候通过反序列化恢复对象。网络传输则涉及到在不同计算机之间的信息交换，由于直接传输对象是不可能的，因此需要先将对象序列化为字节流，然后在网络上传输，接收方收到后进行反序列化恢复为对象。</li>
</ul>
<h1 id="SrtingBuffer和StringBuilder区别"><a href="#SrtingBuffer和StringBuilder区别" class="headerlink" title="SrtingBuffer和StringBuilder区别"></a>SrtingBuffer和StringBuilder区别</h1><ul>
<li><p>StringBuilder和StringBuffer都是Java中用于处理可变的字符串的类，它们之间的主要区别在于线程安全性和可变性。具体来说，StringBuilder类的实现不是线程安全的，因此在单线程环境下它的性能通常更高。而StringBuffer是线程安全的，由于其采用了synchronized关键字实现，这会带来一定的性能开销。</p>
</li>
<li><p>另外，与String类不同的是，StringBuilder和StringBuffer类的对象能够被多次修改，并且不产生新的未使用对象。每次对StringBuilder或StringBuffer的操作都会直接在其本身上进行，而不是生成新的对象。</p>
</li>
</ul>
<p>总的来说，如果你在单线程环境下进行字符串操作，并且对性能有较高要求，那么建议使用StringBuilder。如果你的应用场景需要在多线程环境下保证线程安全，那么可以考虑使用StringBuffer。</p>
<h1 id="Springboot如何获得IOC容器"><a href="#Springboot如何获得IOC容器" class="headerlink" title="Springboot如何获得IOC容器"></a>Springboot如何获得IOC容器</h1><p>在Springboot项目中，获取IOC容器的方式主要有两种。其中一种方法是在Springboot项目中都会存在一个名为SpringApplication的启动类，我们可以通过调用该类的run方法来启动IOC容器。另一种方式是直接从Spring容器中获取Bean实例。在某些特殊情况下，例如在拦截器中获取dao实例时，Bean需要实现某个功能，但该功能必须借助于Spring容器才能实现，此时就必须让该Bean先获取Spring容器。</p>
<h1 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h1><ul>
<li><p>依赖注入（Dependency Injection，简称DI）是一种设计模式，也是Spring框架的核心概念之一。其主要作用是去除Java类之间的依赖关系，实现松耦合，以便于开发和测试。具体来说，依赖注入就是不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p>
</li>
<li><p>此外，依赖注入是控制反转（Inversion of Control，简称IoC）思想的具体实现方式。控制反转是一种程序设计思想，而依赖注入则是其最典型的实践方法。在控制反转中，由第三方（通常称作IOC容器）来控制依赖，把依赖通过构造函数、属性或者工厂模式等方法，注入到类内，这样就极大程度的对类和其依赖进行了解耦。</p>
</li>
</ul>
<h1 id="为什么用security加jwt，为什么不用session"><a href="#为什么用security加jwt，为什么不用session" class="headerlink" title="为什么用security加jwt，为什么不用session"></a>为什么用security加jwt，为什么不用session</h1><ol>
<li>扩展性：Cookie和Session是基于HTTP协议的，随着Web技术的不断发展，如WebSockets等技术的出现，HTTP协议已经无法满足一些复杂的业务需求。新的技术，如Token、JWT等，可以更安全地存储用户信息，并克服了传统技术的一些缺点。</li>
<li>管理方式：JWT理论上用于无状态的请求，其用户管理也只是依赖本身而已。在它的payload中加入过期时间，无需增加额外的管理，只有自动过期的方式。而Session因为存储在服务器端，因此其管理方案就有很多，而且大多都很成熟。</li>
<li>跨平台：JWT可以实现跨平台使用，这是因为它的认证信息是存储在客户端的，而不是像Session一样存储在服务器端。</li>
<li>无状态：与Session不同，JWT不需要在服务器端存储状态信息。这降低了服务器的压力，并提高了系统的可扩展性。</li>
<li>安全性：JWT可以将用户信息加密后存储在客户端，提高了安全性。如果需要访问敏感信息，只需要解密部分数据即可，而不需要像Session一样将整个用户信息暴露给客户端。</li>
</ol>
<ul>
<li>传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。当用户访问应用服务，每个应用服务都会去服务器查看session信息，如果session中没有该用户则说明用户没有登录，此时就会重新认证，而解决这个问题的方法是Session复制、Session黏贴。</li>
<li>如果是基于令牌技术在分布式系统中实现认证则服务端不用存储session，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。</li>
</ul>
<h1 id="RBAC权限模型介绍，权限怎么分配的"><a href="#RBAC权限模型介绍，权限怎么分配的" class="headerlink" title="RBAC权限模型介绍，权限怎么分配的"></a>RBAC权限模型介绍，权限怎么分配的</h1><p>基于角色的访问控制（Role-Based Access Control）{<em>系统可扩展性差。</em>}</p>
<p>基于资源的访问控制（Resource-Based Access Control）{<em>系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。</em>}</p>
<h1 id="redis都有哪些数据类型"><a href="#redis都有哪些数据类型" class="headerlink" title="redis都有哪些数据类型"></a>redis都有哪些数据类型</h1><ul>
<li><p>Redis支持的主要数据类型有五种：string（字符串），hash（哈希），list（列表），set（集合）和zset (sorted set：有序集合)。其中，string 是 Redis 最基本的类型，每个 key 对应一个 value，并且 string 类型是二进制安全的，意味着它可以包含任何数据，如jpg图片或序列化的对象。这种数据类型的值最大能存储 512MB。</p>
</li>
<li><p>在实际业务场景中，string 类型常用来缓存结构体信息，也经常被用来存储用户的session信息、缓存静态文件等。而 hash 类型则是一种键值对的集合，适用于存储对象。list 是一个简单的字符串列表，按插入顺序排序，适用于消息队列、关注列表等场景。set 是一个无序且不重复的字符串集合，适用于抽奖、社交标签等功能。zset（有序集合）和 set 类似，但每个元素都会关联一个 double 类型的分数，用于排序，适用于排行榜等场景。</p>
</li>
</ul>
<h1 id="java-NIO"><a href="#java-NIO" class="headerlink" title="java NIO"></a>java NIO</h1><ol>
<li><h2 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h2><p>NIO（New I&#x2F;O）是Java提供的一种非阻塞I&#x2F;O模型，它在JDK 1.4中引入。与传统的I&#x2F;O模型相比，NIO提供了更高效、更灵活的I&#x2F;O操作方式。</p>
</li>
<li><h2 id="为什么需要NIO"><a href="#为什么需要NIO" class="headerlink" title="为什么需要NIO?"></a><strong>为什么需要NIO?</strong></h2><p>传统的I&#x2F;O模型使用阻塞式I&#x2F;O，在进行读写操作时会导致线程被阻塞，直到数据准备好或者写入完成。这种模型对于并发处理能力较弱，当有大量连接同时请求时，每个连接都需要一个独立的线程来处理，造成资源浪费和性能下降。</p>
<p>而NIO采用了事件驱动的方式，通过Selector轮询注册的通道，只有在通道真正有读写事件发生时才会进行处理，避免了线程被阻塞的情况，提高了系统的并发处理能力。</p>
</li>
<li><p><strong>NIO的实现原理?</strong></p>
<p>NIO的核心组件包括：Channel、Buffer和Selector。</p>
<p>Channel: 类似于传统I&#x2F;O中的流，可以通过Channel进行数据的读取和写入。常见的Channel类型有SocketChannel、ServerSocketChannel、FileChannel等。<br>Buffer: 缓冲区，用于存储数据。在NIO中，所有的数据都是通过Buffer进行读写的。常见的Buffer类型有ByteBuffer、CharBuffer、IntBuffer等。<br>Selector: 选择器，用于监听多个Channel的事件。通过Selector可以实现单线程处理多个通道的读写操作。<br>NIO的工作原理如下：</p>
<ul>
<li>创建一个Selector，并将其注册到需要监听的Channel上。</li>
<li>当有数据准备好时，Selector会轮询已注册的Channel，发现有事件发生的Channel后进行处理。</li>
<li>根据不同的事件类型（读、写、连接、接收），使用对应的方法进行处理。</li>
</ul>
</li>
<li><h2 id="NIO的优点"><a href="#NIO的优点" class="headerlink" title="NIO的优点"></a>NIO的优点</h2><p>高并发性：NIO采用了事件驱动的方式，可以使用单线程处理多个通道的读写操作，提高系统的并发处理能力。<br>非阻塞式I&#x2F;O：NIO模型中的通道是非阻塞的，不会因为某个通道的读写操作而导致线程被阻塞，提高了系统的响应速度和吞吐量。<br>内存管理优化：NIO使用了直接内存缓冲区，可以减少数据在Java堆和操作系统之间的拷贝次数，提高了I&#x2F;O性能。</p>
</li>
<li><h2 id="NIO的缺点"><a href="#NIO的缺点" class="headerlink" title="NIO的缺点"></a>NIO的缺点</h2><p>复杂性较高：相比传统的阻塞式I&#x2F;O模型，NIO的编程模型更加复杂，需要处理事件驱动、多路复用等概念。<br>对编程人员要求较高：由于NIO的复杂性，对编程人员的技术要求较高，需要熟悉NIO相关的API和底层原理。</p>
</li>
<li><h2 id="NIO的使用注意事项"><a href="#NIO的使用注意事项" class="headerlink" title="NIO的使用注意事项"></a>NIO的使用注意事项</h2><p>需要合理设置缓冲区大小：过小的缓冲区可能导致频繁的读写操作，影响性能；过大的缓冲区可能造成资源浪费。<br>注意正确释放资源：在使用完Channel和Buffer后，需要及时关闭并释放资源，避免出现资源泄露问题。<br>谨慎处理异常情况：NIO中的异常处理相对复杂，需要仔细处理各种异常情况，以保证程序的稳定性和可靠性。</p>
</li>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NIO是一种非阻塞I&#x2F;O模型，通过事件驱动和选择器机制实现高效的I&#x2F;O操作。它具有高并发性、非阻塞式I&#x2F;O和内存管理优化等优点，但也存在复杂性较高和对编程人员要求较高的缺点。在使用NIO时需要注意合理设置缓冲区大小、正确释放资源和谨慎处理异常情况。</p>
</li>
</ol>
<h1 id="java的面向对象都有哪些"><a href="#java的面向对象都有哪些" class="headerlink" title="java的面向对象都有哪些"></a>java的面向对象都有哪些</h1><p>Java面向对象编程是一种编程范式，它包括三大基本特征：封装、继承和多态。封装是指将数据和方法绑定在一起，形成一个类，从而隐藏了类的实现细节；继承是指从已有的类派生出新的类，新的类继承了原有类的属性和方法，并可以添加新的属性和方法；多态是指同一种类型的对象在不同的情况下具有不同的行为。</p>
<p>在Java中，面向对象的核心概念包括对象、类和实例。对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类是一个模板，它描述一类对象的行为和状态。每个对象都是某个类的实例，它们可以拥有相同的属性和方法。</p>
<p>另外，抽象、接口、方法和重载也是Java面向对象编程的重要概念。抽象是指将一类对象的共同特征总结出来构造类的过程，它忽略了对象之间的差异。接口定义了一种规范，规定了实现此接口的类必须提供哪些方法。方法是一段具有特定功能的代码块，可以接受参数并返回结果。重载是指在一个类中允许存在一个以上同名的方法，但这些方法的参数数量或类型必须不同。</p>
<h1 id="java的容器都有哪些"><a href="#java的容器都有哪些" class="headerlink" title="java的容器都有哪些"></a>java的容器都有哪些</h1><p>Java的容器主要包括以下几种类型：</p>
<ol>
<li>数组(Array)：这是Java最基础的容器类型，它能够容纳固定数量的对象。</li>
<li>集合(Collection)：这是一种动态的容器类型，可以容纳任意数量的对象。其中一些常用的集合类型包括List、Set和Queue。例如，List是一个有序的集合，允许元素的重复，并提供了诸如add()添加元素、remove()移除元素、获取表的大小size()、get()获取元素等方法；而Set是一个不允许元素重复且不保持顺序的集合。</li>
<li>Map：这是一种关联数组，存储的是键值对（key-value pairs）。每个键都与一个值相关联，这样可以方便地通过键查找值。</li>
<li>字符串(StringBuilder和StringBuffer)：这两种类型的对象主要用于处理和操作字符串。其中，StringBuilder类的对象用于处理长度可变的字符串，而StringBuffer类的对象则用于处理内容不可变的字符串。</li>
</ol>
<h1 id="什么是java反射"><a href="#什么是java反射" class="headerlink" title="什么是java反射"></a>什么是java反射</h1><p>Java反射是一种强大的编程技术，它允许运行中的程序访问、检查和修改一个类的属性和方法。具体来说，反射使程序员能够在运行时知道任意一个类的所有属性和方法，无论这个类是在什么时候加载的。此外，反射还使得对于任意一个对象，都能够调用它的任意方法和属性，甚至可以在运行时改变它的属性。</p>
<p>Java反射机制的核心在于程序运行时动态加载类以及获取该类的详细信息，包括类的属性和方法。这一过程依赖于JVM得到的Class对象，通过这个对象，程序能够获取到类的各种信息，并进行反编译等操作。</p>
<p>Java反射机制提供了许多功能，包括但不限于：判断运行时任意对象所属的类；创建运行时任意类的对象；判断运行时任意类所具有的成员变量和方法；以及在运行时调用任意对象的方法。这些特性使得Java被视为具有动态性质的一种语言。</p>
<p>总的来说，Java反射技术让程序在运行时可以获取类的信息、操作类对象、动态调用方法、创建类实例等，从而在很大程度上增强了程序的灵活性和可扩展性。</p>
<h1 id="springMVC有哪些组件"><a href="#springMVC有哪些组件" class="headerlink" title="springMVC有哪些组件"></a>springMVC有哪些组件</h1><p>SpringMVC的组件有以下几种：前端控制器（DispatcherServlet），处理器映射器（HandlerMapping），处理器适配器（HandlerAdapter），拦截器（HandlerInterceptor），语言环境处理器（LocaleResolver）等  。其中，前端控制器（DispatcherServlet）是请求的入口，处理器映射器（HandlerMapping）负责让请求和控制器建立一一对应的关联，处理器适配器（HandlerAdapter）运用了设计模式中的适配器模式，统一调用不同的Handler，拦截器（HandlerInterceptor）可以在请求处理之前或之后进行一些操作，语言环境处理器（LocaleResolver）则用于解析客户端请求的语言环境。</p>
<h1 id="springboot的优势"><a href="#springboot的优势" class="headerlink" title="springboot的优势"></a>springboot的优势</h1><p>Spring Boot是Spring框架的一种扩展，其优势主要体现在以下几个方面：首先，Spring Boot可以快速构建独立的Spring应用。它依靠大量的注解实现自动化配置，开发者只需添加相应的场景依赖，Spring Boot就会自动进行配置，从而无需额外手动添加配置就可以快速构建出一个独立的Spring应用。其次，Spring Boot可以直接嵌入Tomcat、Jetty和Undertow服务器，无需部署WAR文件。此外，Spring Boot还提供了诸如自动starter依赖、自动配置Spring以及第三方功能、生产级别的监控、健康检查以及外部优化配置等一系列特性，极大地简化了开发、部署效率。最后，Spring Boot与云计算的天然集成，使其更适应现代化的软件开发和部署。</p>
<ul>
<li><p>简化依赖</p>
<p>比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p>
</li>
</ul>
<p><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code><br>    <code>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</code><br><code>&lt;/dependency&gt;</code><br>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p>
<p><code>&lt;!-- .....省略其他依赖 --&gt;</code><br><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>    <code>&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</code><br>    <code>&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</code><br>    <code>&lt;scope&gt;compile&lt;/scope&gt;</code><br><code>&lt;/dependency&gt;</code><br><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>    <code>&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</code><br>    <code>&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</code><br>    <code>&lt;scope&gt;compile&lt;/scope&gt;</code><br><code>&lt;/dependency&gt;</code><br>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p>
<ul>
<li><p>简化配置</p>
<p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p>
</li>
</ul>
<p>我新建一个类，但是我不用 @Service注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要@Configuration 和@Bean两个注解即可，如下：</p>
<p><code>public class TestService &#123;</code><br>    <code>public String sayHello () &#123;</code><br>        <code>return &quot;Hello Spring Boot!&quot;;</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p><code>import org.springframework.context.annotation.Bean;</code><br><code>import org.springframework.context.annotation.Configuration;</code></p>
<p><code>@Configuration</code><br><code>public class JavaConfig &#123;</code><br>    <code>@Bean</code><br>    <code>public TestService getTestService() &#123;</code><br>        <code>return new TestService();</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p>@Configuration表示该类是个配置类，@Bean表示该方法返回一个 Bean。这样就把TestService作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用@Resource注解注入进来即可使用，非常方便。</p>
<p><code>@Resource private TestService testService;</code></p>
<p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p>
<ul>
<li><p>简化部署</p>
<p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。</p>
</li>
</ul>
<p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p>
<ul>
<li><p>简化监控</p>
<p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p>
<h1 id="springboot的核心注解文件"><a href="#springboot的核心注解文件" class="headerlink" title="springboot的核心注解文件"></a>springboot的核心注解文件</h1></li>
</ul>
<p>Spring Boot的核心注解是@SpringBootApplication，这个注解通常用在启动类上，主要的功能是让Spring Boot自动为程序进行必要的配置。它主要由以下三个注解组成：@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。</p>
<ul>
<li>@SpringBootConfiguration是一个组合注解，其中包含了@Configuration，这使得它可以替代applicationContext.xml配置文件，所有能在配置文件里完成的事情都可以通过这个注解所在的类来进行注册。</li>
<li>@EnableAutoConfiguration是用来打开自动配置的功能，可以根据classpath下的jar包自动配置，例如数据源自动配置等。如果需要关闭某个自动配置的选项，可以使用类似以下的代码：@SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan是Spring框架中的一个注解，它会扫描指定包路径下的所有类，并将这些类注册为bean，这样就可以在其他地方使用这些bean了。</li>
</ul>
<p>此外，Spring Boot还提供了两个全局配置文件：application.properties和application.yaml，这两个文件可以对一些默认配置值进行修改。这两个文件一般存放在项目的src&#x2F;main&#x2F;resources目录下。</p>
<h1 id="什么是spring-ioc"><a href="#什么是spring-ioc" class="headerlink" title="什么是spring ioc"></a>什么是spring ioc</h1><p>Spring IOC是一种让服务消费者不直接依赖于服务提供者的组件设计方式，是一种减少类与类之间依赖的设计原则。它将对象的创建权力反转给Spring框架，通过在IOC容器中创建对象，实现了对象之间的解耦。在传统的Java开发中，一个类想要使用另一个类的方法，就必须在这个类中创建这个类的对象，这样可能会导致程序出现耦合性问题。而Spring IOC通过将对象的创建和管理交给Spring容器，使得对象之间的依赖关系由容器来维护，从而降低了程序的耦合性，提高了程序的可维护性和可扩展性。</p>
<h1 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h1><p>CAS是Compare and Swap的缩写，即比较并交换。它是一种多线程同步的算法，用于实现多线程环境下的原子操作。在CAS中，操作数值的时候，会先比较当前内存中的值是否与期望值相等，如果相等，则将新值写入内存；否则，不做任何操作。CAS操作是一种乐观锁，它不需要加锁，因此可以提高并发性能。CAS常用于实现线程安全的数据结构，如原子类和自旋锁等。</p>
<h1 id="什么是双亲委派模型-优点是什么"><a href="#什么是双亲委派模型-优点是什么" class="headerlink" title="什么是双亲委派模型 优点是什么"></a>什么是双亲委派模型 优点是什么</h1><p>双亲委派模型是Java中的一种类加载机制，它指的是类加载器在加载一个类时，先将该请求委派给父类加载器去完成，如果父类加载器还存在父类加载器，则继续向上委派，直到委派到最顶层的启动类加载器为止。如果父类加载器无法完成类的加载请求，子加载器才会尝试自己去加载。这种机制可以避免重复加载，保证了Java程序的稳定性和安全性。</p>
<p>双亲委派模型的优点主要有两个：</p>
<ol>
<li>避免类的重复加载：由于类加载器在加载类时会先委派给父类加载器，因此可以避免同一个类被多次加载，从而节省了内存空间。</li>
<li>提高安全性：由于父类加载器在委派给子类加载器时会先检查该类是否已经被加载过，如果已经被加载过，则直接返回已经加载的类，从而避免了恶意类的加载，提高了Java程序的安全性。</li>
</ol>
<h1 id="一个对象垃圾回收的全过程"><a href="#一个对象垃圾回收的全过程" class="headerlink" title="一个对象垃圾回收的全过程"></a>一个对象垃圾回收的全过程</h1><p>一个对象从加载到JVM再到被GC清除，它的过程可以分为几个阶段：类加载、对象实例化、对象使用和垃圾回收。新创建的对象首先会被分配到Eden区。随着程序的运行，Eden区可能会满或者快满，这时就会进行一次Minor GC，也就是清理过程。在这个过程中，不被引用的对象会被直接清除掉；仍然有引用的对象，但如果它们的存在时间较长，则会被移动到S0区。</p>
<p>当Eden区再次快满的时候，会再进行一次清理，这次清理会涉及到Eden区和Survivor A区。存活的对象会被放入Survivor A区，而Eden区则被清空。</p>
<p>这个过程并不是一次性的，而是会在JVM运行时持续发生。每次垃圾回收后，Eden区会继续提供堆内存供新的对象存放。这就是一个对象从创建到被垃圾回收的全过程。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">John Doe</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/posts/4fd0e23c.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/posts/4fd0e23c.html')">Java面经</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/posts/4fd0e23c.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java面经&amp;url=http://example.com/posts/4fd0e23c.html&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/4a17b156.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9Fspring%E6%94%AF%E6%8C%81%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9F%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">什么叫事务传播行为？spring支持几种事务传播行为？都是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%A4%9A%E6%80%81"><span class="toc-number">2.</span> <span class="toc-text">什么是java多态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringAOP-%E4%BB%A3%E7%90%86%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">SpringAOP 代理中有几种方式，分别是什么，有什么特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFASM%E6%A1%86%E6%9E%B6"><span class="toc-number">4.</span> <span class="toc-text">什么是ASM框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%97%B6%EF%BC%8C%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%BA%E7%A9%BA%E6%97%B6%E4%B8%8D%E4%BF%AE%E6%94%B9%EF%BC%8C%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99sql%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%8A%A8%E6%80%81sql%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86jdk%E5%92%8Ccglib%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">spring两种代理jdk和cglib的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp-ip-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">tcp ip 三次握手四次挥手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E5%92%8Chttps%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">http和https什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86"><span class="toc-number">9.</span> <span class="toc-text">对称性加密和非对称性加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">cookie和session的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E5%95%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%87%92%E6%B1%89%E8%A6%81%E5%8F%8C%E9%87%8D%E5%88%A4%E6%96%AD"><span class="toc-number">11.</span> <span class="toc-text">实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AAArrayList%E7%9A%84%E5%B9%B6%E9%9B%86%E3%80%81%E4%BA%A4%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86"><span class="toc-number">12.</span> <span class="toc-text">怎么计算两个ArrayList的并集、交集、差集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9-%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84List"><span class="toc-number">13.</span> <span class="toc-text">ArrayList和LinkedList区别，优缺点 是不是线程安全，怎么使用一个线程安全的的List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#currentHashMap-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1-7%E5%92%8C1-8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">currentHashMap 怎么保证线程安全 1.7和1.8有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">15.</span> <span class="toc-text">怎么理解哈希冲突</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">16.</span> <span class="toc-text">怎样理解序列化和反序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SrtingBuffer%E5%92%8CStringBuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">SrtingBuffer和StringBuilder区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Springboot%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">18.</span> <span class="toc-text">Springboot如何获得IOC容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">19.</span> <span class="toc-text">什么是依赖注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8security%E5%8A%A0jwt%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8session"><span class="toc-number">20.</span> <span class="toc-text">为什么用security加jwt，为什么不用session</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RBAC%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%9A%84"><span class="toc-number">21.</span> <span class="toc-text">RBAC权限模型介绍，权限怎么分配的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">22.</span> <span class="toc-text">redis都有哪些数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-NIO"><span class="toc-number">23.</span> <span class="toc-text">java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFNIO"><span class="toc-number">23.1.</span> <span class="toc-text">什么是NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81NIO"><span class="toc-number">23.2.</span> <span class="toc-text">为什么需要NIO?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">23.3.</span> <span class="toc-text">NIO的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">23.4.</span> <span class="toc-text">NIO的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">23.5.</span> <span class="toc-text">NIO的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">23.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">24.</span> <span class="toc-text">java的面向对象都有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E7%9A%84%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">25.</span> <span class="toc-text">java的容器都有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%8F%8D%E5%B0%84"><span class="toc-number">26.</span> <span class="toc-text">什么是java反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springMVC%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-number">27.</span> <span class="toc-text">springMVC有哪些组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">28.</span> <span class="toc-text">springboot的优势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%96%87%E4%BB%B6"><span class="toc-number">29.</span> <span class="toc-text">springboot的核心注解文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-ioc"><span class="toc-number">30.</span> <span class="toc-text">什么是spring ioc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-number">31.</span> <span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B-%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">32.</span> <span class="toc-text">什么是双亲委派模型 优点是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">33.</span> <span class="toc-text">一个对象垃圾回收的全过程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4fd0e23c.html" title="Java面经">Java面经</a><time datetime="2023-12-01T01:02:48.000Z" title="发表于 2023-12-01 09:02:48">2023-12-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4a17b156.html" title="Hello World">Hello World</a><time datetime="2023-11-30T01:59:03.499Z" title="发表于 2023-11-30 09:59:03">2023-11-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="John Doe" target="_blank">John Doe</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.10",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 John Doe 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>