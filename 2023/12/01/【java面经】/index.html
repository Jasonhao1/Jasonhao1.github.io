<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java面经 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么叫事务传播行为？spring支持几种事务传播行为？都是什么事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。在TransactionDefinition接口中，Spring规定了7种类型的事务传播行为。这些类型分别是：  Propagation.REQUIRED：这是spring默认的事务传播行为。如果当前方法存在事务，则加入该事务；如果当前方法不存在事务，">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面经">
<meta property="og:url" content="http://example.com/2023/12/01/%E3%80%90java%E9%9D%A2%E7%BB%8F%E3%80%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="什么叫事务传播行为？spring支持几种事务传播行为？都是什么事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。在TransactionDefinition接口中，Spring规定了7种类型的事务传播行为。这些类型分别是：  Propagation.REQUIRED：这是spring默认的事务传播行为。如果当前方法存在事务，则加入该事务；如果当前方法不存在事务，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-12-01T01:02:48.000Z">
<meta property="article:modified_time" content="2023-12-01T01:03:32.951Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/01/%E3%80%90java%E9%9D%A2%E7%BB%8F%E3%80%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 09:03:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-01T01:02:48.000Z" title="发表于 2023-12-01 09:02:48">2023-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-01T01:03:32.951Z" title="更新于 2023-12-01 09:03:32">2023-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java面经"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="什么叫事务传播行为？spring支持几种事务传播行为？都是什么"><a href="#什么叫事务传播行为？spring支持几种事务传播行为？都是什么" class="headerlink" title="什么叫事务传播行为？spring支持几种事务传播行为？都是什么"></a>什么叫事务传播行为？spring支持几种事务传播行为？都是什么</h1><p>事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。在TransactionDefinition接口中，Spring规定了7种类型的事务传播行为。这些类型分别是：</p>
<ol>
<li>Propagation.REQUIRED：这是spring默认的事务传播行为。如果当前方法存在事务，则加入该事务；如果当前方法不存在事务，则创建一个新的事务。</li>
<li>Propagation.SUPPORTS：如果当前方法存在事务，则加入该事务；如果当前方法不存在事务，则使用非事务方式执行。</li>
<li>Propagation.MANDATORY：只能在存在事务的方法中被调用。如果当前方法没有事务，则会抛出异常。</li>
<li>Propagation.REQUIRES_NEW：如果当前方法存在事务，则把当前事务挂起，重新开启一个新事务。</li>
<li>Propagation.NOT_SUPPORTED：不支持事务，如果当前方法存在事务，则把当前事务挂起。</li>
<li>Propagation.NEVER：不支持事务，要求当前方法必须不存在事务。</li>
<li>Propagation.NESTED：嵌套事务，如果当前方法存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前方法不存在事务，则与Propagation.REQUIRED类似，创建一个新的事务。</li>
</ol>
<p>这些事务传播行为可以帮助我们确定客户端和被调用端的事务边界，例如多个具有事务控制的service的相互调用时所形成的复杂的事务边界控制。</p>
<h1 id="什么是java多态"><a href="#什么是java多态" class="headerlink" title="什么是java多态"></a>什么是java多态</h1><p>Java多态是面向对象编程的重要特性之一，它指的是同一个行为具有多个不同表现形式或形态的能力。这种特性主要体现在子类继承父类的属性和方法后，可以具有不同的数据类型或表现出不同的行为。</p>
<p>在Java中，多态的实现主要依赖于继承、接口和重写这三个概念。继承使得子类能够获得父类的属性和方法，接口则规定了一组方法的规范，重写则允许子类重新定义这些方法以实现自己的功能。特别地，Java提供了非常方便的特性，即子类对象可以直接赋给父类变量，虽然看起来变量是父类型，但实际执行的是子类的重写方法。</p>
<p>总的来说，Java多态让程序设计变得更加灵活和动态，大大提高了代码的可复用性和扩展性。</p>
<h1 id="SpringAOP-代理中有几种方式，分别是什么，有什么特点"><a href="#SpringAOP-代理中有几种方式，分别是什么，有什么特点" class="headerlink" title="SpringAOP 代理中有几种方式，分别是什么，有什么特点"></a>SpringAOP 代理中有几种方式，分别是什么，有什么特点</h1><p>Spring AOP代理主要有两种方式：JDK动态代理和CGLib动态代理。</p>
<p>JDK动态代理是实现InvocationHandlet接口，并重写invoke方法来创建动态代理。它主要应用于目标类实现了接口的情况。其核心特性在于无需修改目标对象的代码，通过运行时增强目标对象来实现AOP功能。</p>
<p>另一种是CGLib动态代理，它通过继承目标类的方式，利用ASM框架生成子类来实施动态代理。当目标类没有实现接口时，CGLib动态代理就发挥了作用。因此，CGLib动态代理在应用上比JDK动态代理更为广泛，但需要注意的是，由于CGLib动态代理是通过继承目标类的方式生成代理类，因此如果目标类被final修饰，那么就无法使用CGLib动态代理了。</p>
<h1 id="什么是ASM框架"><a href="#什么是ASM框架" class="headerlink" title="什么是ASM框架"></a>什么是ASM框架</h1><p>ASM，全称Java字节码操作和分析框架，是一个可以用于修改现有类文件或动态生成类文件的框架。它提供了一种在二进制形式下直接操作Java字节码的方式，使得开发者能够灵活地创建、修改或者分析Java类的字节码。</p>
<p>具体来说，ASM可以在类被加载到Java虚拟机之前动态改变类行为，这为我们在运行时改变类的结构或者行为提供了可能。此外，ASM还提供了一些常见的字节码转换和分析算法，这些算法可以帮助我们构建定制的复杂转换和代码分析工具。</p>
<p>总的来说，ASM框架由于其强大的功能和灵活性，广泛应用于许多Java应用中，如Spring AOP、Hibernate等，帮助我们完成诸如字节码增强、代码混淆等任务。</p>
<h1 id="mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）"><a href="#mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）" class="headerlink" title="mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）"></a>mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）</h1><p>在MyBatis中，可以使用动态SQL来实现部分字段为空时不修改的需求。具体做法是使用<code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>和<code>&lt;otherwise&gt;</code>标签来构建动态SQL语句。以下是一个示例：</p>
<ol>
<li>首先，在Mapper接口中定义一个方法，例如<code>updateUser</code>，并传入一个<code>User</code>对象作为参数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，在对应的XML映射文件中编写动态SQL语句。假设我们要更新的表名为<code>user</code>，需要更新的字段有<code>name</code>、<code>age</code>和<code>email</code>，其中<code>email</code>可以为空。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name = #&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">                age = #&#123;age&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了<code>&lt;if&gt;</code>标签来判断字段是否为空，如果不为空，则将该字段添加到<code>SET</code>子句中。这样，当某个字段为空时，对应的SQL语句就不会包含这个字段，从而实现了部分字段为空时不修改的需求。</p>
<h1 id="spring两种代理jdk和cglib的区别"><a href="#spring两种代理jdk和cglib的区别" class="headerlink" title="spring两种代理jdk和cglib的区别"></a>spring两种代理jdk和cglib的区别</h1><p>JDK动态代理和CGLib动态代理是Spring框架中两种常用的代理实现方式，它们在实际应用中有着显著的区别。首先，JDK动态代理是基于接口的代理模式，如果被代理目标没有接口，那么JDK动态代理将无法工作。在这种情况下，Spring会通过Java的反射机制生成被代理接口的新的匿名实现类，并重写其中的增强方法。相比之下，CGLib动态代理则是利用ASM开源包，对代理对象类的class文件进行加载，并通过修改其字节码来生成子类以处理代理逻辑。</p>
<p>需要注意的是，JDK动态代理和CGLib动态代理在实际应用中有一些特定的使用场景。例如，如果要被代理的对象是一个实现类，那么Spring默认会采用JDK动态代理来完成操作。而如果被代理的对象不是一个实现类，那么Spring会强制使用CGLib来实现动态代理。此外，由于CGLib动态代理是通过字节码底层继承要代理类来实现的，因此在被代理类被final关键字修饰的情况下，CGLib动态代理将会失败。</p>
<p>在日常开发中，了解这两种代理方式的差异和适用场景是非常重要的。基于JDK和CGLib的动态代理在Spring AOP等功能中发挥着关键作用，根据具体的需求和情况选择合适的代理方式能够有效地提高代码的性能和可维护性。</p>
<h1 id="tcp-ip-三次握手四次挥手"><a href="#tcp-ip-三次握手四次挥手" class="headerlink" title="tcp ip 三次握手四次挥手"></a>tcp ip 三次握手四次挥手</h1><p>TCP&#x2F;IP是一种常用的网络通信协议，用于在计算机网络中传输数据。而三次握手和四次挥手是TCP协议的连接建立和断开过程中的关键步骤。</p>
<ol>
<li><p>三次握手是指在建立TCP连接时，客户端和服务器之间进行的三次通信。	</p>
<ul>
<li>第一次握手：客户端发送一个请求连接的数据包（SYN）到服务器，并进入SYN_SENT状态。</li>
<li>第二次握手：服务器收到请求后，如果同意连接，则发送一个确认数据包（SYN+ACK）回应客户端，并进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的回应后，再发送一个确认数据包（ACK）给服务器，确认连接。客户端和服务器都进入已连接状态（ESTABLISHED），可以进行数据传输。</li>
</ul>
</li>
<li><p>四次挥手是指在断开TCP连接时，客户端和服务器之间进行的四次通信。</p>
<ul>
<li><p>第一次挥手：当客户端想要关闭连接时，发送一个“关闭连接”的请求给服务器，并进入FIN_WAIT1状态。</p>
</li>
<li><p>第二次挥手：服务器收到关闭请求后，发送一个确认数据包（ACK）给客户端，并进入CLOSE_WAIT状态。此时，服务器仍然可以发送数据给客户端。</p>
</li>
<li><p>第三次挥手：服务器准备关闭连接时，发送一个“关闭连接”的请求给客户端，并进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：客户端收到关闭请求后，发送一个确认数据包（ACK）给服务器，并进入TIME_WAIT状态。服务器收到确认后，进入CLOSED状态，客户端经过一段时间后也进入CLOSED状态。</p>
</li>
</ul>
</li>
</ol>
<p>通过三次握手和四次挥手，TCP协议可以建立可靠的连接和安全地关闭连接，以确保数据的可靠传输。</p>
<h1 id="http和https什么区别"><a href="#http和https什么区别" class="headerlink" title="http和https什么区别"></a>http和https什么区别</h1><ol>
<li>安全性：HTTP是明文传输，数据在传输过程中是不加密的，可能被攻击者窃听和篡改。而HTTPS通过使用 SSL&#x2F;TLS 协议对数据进行加密和认证，保证了传输的安全性，使得攻击者无法轻易窃听和篡改数据。</li>
<li>数据完整性：HTTP在传输过程中没有提供数据的完整性校验，因此数据在传输过程中可能被篡改或损坏。而HTTPS使用加密哈希算法来确保数据完整性，一旦数据被篡改，接收方可以通过校验和发现并丢弃损坏的数据。</li>
<li>端口号：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口进行通信。这是因为HTTPS需要使用加密算法进行数据加密和解密，使用了特定的端口来区分普通的HTTP请求。</li>
<li>证书：HTTPS需要使用证书来对服务器进行身份验证，确保与客户端进行安全通信的是合法的服务器。证书由受信任的第三方证书机构（CA）签发，用于证明服务器的合法性和可信度。</li>
</ol>
<p>总的来说，HTTPS相对于HTTP在安全性方面提供了更好的保护，适用于需要保护用户敏感信息的场景，如在线支付、个人账户登录等。而HTTP则适用于不需要保密和完整性的一般数据传输场景。</p>
<h1 id="对称性加密和非对称性加密"><a href="#对称性加密和非对称性加密" class="headerlink" title="对称性加密和非对称性加密"></a>对称性加密和非对称性加密</h1><ul>
<li>对称性加密使用相同的密钥用于加密和解密数据。发送方使用相同的密钥将明文加密成密文，接收方使用相同的密钥将密文解密还原为明文。对称性加密算法的加密速度通常比非对称性加密算法更快，但密钥的传输管理需要保持机密性，否则会增加安全风险。</li>
<li>非对称性加密使用了一对不同的密钥（分别为公钥，私钥）。发送方使用接收方的公钥对数据源进行加密，接收方使用自己的私钥进行解密。反之，发送方也可以使用自己的私钥进行签名，接收方使用发送方的公钥验证签名的真实性，因为即使公钥泄露，私钥任然保持机密。</li>
<li>对称加密和非对称加密各有优缺点，通常在实际应用中会结合使用。</li>
<li>一种常见的做法是，使用非对称加密算法来安全地传输对称加密所需的密钥。发送方用接收方的公钥对密钥进行加密，然后将加密后的密钥发送给接收方。接收方使用自己的私钥解密得到对称密钥，接下来使用对称加密算法对数据进行加密和解密。</li>
<li>这种组合的方式可以实现高效的对称加密和安全的密钥交换，同时保证了数据的保密性和完整性。常见的实际应用中使用的加密协议，如SSL&#x2F;TLS，就采用了对称加密和非对称加密的结合。</li>
</ul>
<h1 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h1><ol>
<li>存储位置：cookie是存储在客户端（浏览器）中的小型文本文件，每次请求时都会包含在HTTP头中发送到服务器。而session存储在服务器端，通常存储在内存中或者持久化到数据库或文件系统中。</li>
<li>数据安全性：cookie中的数据可以被客户端修改和篡改，因此不适合存储敏感信息。而session存储在服务器端，只有sessionID存储在客户端的cookie中，所有的数据处理都在服务端进行，相对更安全。</li>
<li>存储容量：cookie的存储容量有限，通常最大为几kb，而session的存储容量通常没有明确限制，可根据服务器的配置和处理能力进行调整。</li>
<li>生命周期：cookie可以设置过期时间，可以是会话级别（关闭流浏览器即失效）或具体的日期和时间。而session可以设置超时时间，一旦超过时间没有活动，服务器会自动销毁该session。</li>
<li>跨页面传递：cookie可以在不同页面之间共享，并在每次请求时发送到服务器。而session通常通过在cookie中存储一个sessionID,通过该id在服务器端找到相应的session数据。</li>
</ol>
<p>总的来说，cookie适合存储一些较小的非敏感数据，可以实现跨页面的状态跟踪。而session适合存储敏感信息和大量数据，可以实现更安全的用户会话管理。在实际开发中，cookie和session可以结合使用来满足不同场景的需求。</p>
<h1 id="实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断"><a href="#实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断" class="headerlink" title="实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断"></a>实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断</h1><ul>
<li><p>实现单例对象的方式主要有饿汉式和懒汉式两种。饿汉式是在类被加载的时候就创建了单例对象，所以饿汉式的优点是线程安全的，获取单例对象时不需要加锁。然而，这种方式的缺点是不管是否需要，对象都会被创建，可能会造成不必要的资源浪费。</p>
</li>
<li><p>相较于饿汉式，懒汉式在第一次调用getInstance方法时才创建对象。为了解决懒汉式在多线程环境下可能创建多个实例的问题，需要采用双重判断锁定（double-checked locking）来确保线程安全。这样既实现了延时加载，又保证了线程安全性，但同时也使得代码相对复杂。</p>
</li>
</ul>
<p>综上，饿汉式适合在对象创建成本较低，且对性能要求较高的场景下使用；而懒汉式适合在对象创建成本较高，且可能需要延时加载以节省资源的场景下使用。具体选择哪种方式，需要根据实际情况和需求来判断。</p>
<h1 id="怎么计算两个ArrayList的并集、交集、差集"><a href="#怎么计算两个ArrayList的并集、交集、差集" class="headerlink" title="怎么计算两个ArrayList的并集、交集、差集"></a>怎么计算两个ArrayList的并集、交集、差集</h1><p>要计算两个ArrayList的并集、交集和差集，可以使用Java中的<code>retainAll()</code>、（<em>计算交集</em>）；<code>removeAll()</code>（<em>计算差集</em>）和<code>addAll()</code>（<em>计算并集</em>）方法。</p>
<h1 id="ArrayList和LinkedList区别，优缺点-是不是线程安全，怎么使用一个线程安全的的List"><a href="#ArrayList和LinkedList区别，优缺点-是不是线程安全，怎么使用一个线程安全的的List" class="headerlink" title="ArrayList和LinkedList区别，优缺点 是不是线程安全，怎么使用一个线程安全的的List"></a>ArrayList和LinkedList区别，优缺点 是不是线程安全，怎么使用一个线程安全的的List</h1><ul>
<li><p>ArrayList是基于动态数组实现的，它允许随机访问任意位置的元素，但插入和删除元素时需要移动大量元素，性能较低。LinkedList是基于双向链表实现的，插入和删除元素时只需要修改指针，性能较高，但随机访问元素时需要遍历链表，性能较低。</p>
</li>
<li><p>ArrayList的优点：随机访问性能好，查询速度快；缺点：插入和删除元素时性能较差。</p>
</li>
<li><p>LinkedList的优点：插入和删除元素时性能较好；缺点：随机访问元素时性能较差。</p>
</li>
<li><p>ArrayList和LinkedList都不是线程安全的，如果需要在多线程环境下使用List，可以使用线程安全的List实现类，如Vector或Collections.synchronizedList()方法返回的同步List。这些线程安全的List在多线程环境下可以保证数据的一致性和安全性。</p>
</li>
</ul>
<h1 id="currentHashMap-怎么保证线程安全-1-7和1-8有什么区别"><a href="#currentHashMap-怎么保证线程安全-1-7和1-8有什么区别" class="headerlink" title="currentHashMap 怎么保证线程安全 1.7和1.8有什么区别"></a>currentHashMap 怎么保证线程安全 1.7和1.8有什么区别</h1><ul>
<li><p>ConcurrentHashMap是线程安全的，它采用了一种分段锁技术。在ConcurrentHashMap中，有一个Segment数组，每个Segment对象都有一个HashEntry链表。当进行put操作时，会将数据插入到对应的Segment中，并锁定该Segment。这样其他线程就无法对该Segment中的HashEntry链表进行操作，从而保证了线程安全。</p>
</li>
<li><p>在JDK 1.7和1.8版本中，这种实现方式有所不同。在1.7版本中，对整个Segment加锁，而在1.8版本中，锁的粒度降低到HashEntry（首节点）。这种改变使得在数据比较多的情况下访问速度得到了提升，因为现在不需要遍历整个链表。另外，在1.8版本的实现中，还采用了Node + CAS + Synchronized来保证并发安全。</p>
</li>
</ul>
<p>此外，对于扩容操作也是线程安全的。在JDK1.7中，一旦初始化后Segment数组就不会再进行扩容，而HashEntry是可以扩容的，且该扩容操作是在put方法中进行的，由于put操作已经被使用锁保证了线程安全，所以也保证了扩容的线程安全性。</p>
<h1 id="怎么理解哈希冲突"><a href="#怎么理解哈希冲突" class="headerlink" title="怎么理解哈希冲突"></a>怎么理解哈希冲突</h1><p>哈希冲突是指在哈希表中，不同的键（Key）可能会被哈希函数计算出相同的哈希值，即地址，这种现象称为哈希冲突。这是由于哈希函数是将任意长度的输入转化为固定长度的输出，转化过程中有可能会出现碰撞。</p>
<p>虽然哈希冲突是无法避免的，但有多种方法可以解决这个问题。其中常见的解决策略包括开放定址法、线性探测法、平方探测法、再哈希法、链地址法和建立公共溢出区等。例如，链地址法就是在每个位桶实现的时候，采用链表（或者从JDK 1.8开始，采用链表+红黑树）的数据结构来存储发生哈希冲突的输入域的关键字。</p>
<h1 id="怎样理解序列化和反序列化"><a href="#怎样理解序列化和反序列化" class="headerlink" title="怎样理解序列化和反序列化"></a>怎样理解序列化和反序列化</h1><p>序列化是将内存中的对象转化为自己序列的过程，以便将其存储在磁盘文件或者通过网络进行传输。反序列化则是将这个字节序列再次转化回对象的过程。</p>
<ul>
<li>java语言提供了一套丰富的API来实现对象的序列化和反序列化。当一个类实现了Serializable接口，他就被序列化。在进行序列化时，java会使用一个叫做serialVersionUID的字段来保证反序列化时类的版本的正确性。</li>
<li>序列化的主要应用包括对象的持久化和网络传输。持久化是指将对象转化为字节序列并存储在硬盘上，这样即使JVM停止运行，对象的信息也不会丢失，可以在需要的时候通过反序列化恢复对象。网络传输则涉及到在不同计算机之间的信息交换，由于直接传输对象是不可能的，因此需要先将对象序列化为字节流，然后在网络上传输，接收方收到后进行反序列化恢复为对象。</li>
</ul>
<h1 id="SrtingBuffer和StringBuilder区别"><a href="#SrtingBuffer和StringBuilder区别" class="headerlink" title="SrtingBuffer和StringBuilder区别"></a>SrtingBuffer和StringBuilder区别</h1><ul>
<li><p>StringBuilder和StringBuffer都是Java中用于处理可变的字符串的类，它们之间的主要区别在于线程安全性和可变性。具体来说，StringBuilder类的实现不是线程安全的，因此在单线程环境下它的性能通常更高。而StringBuffer是线程安全的，由于其采用了synchronized关键字实现，这会带来一定的性能开销。</p>
</li>
<li><p>另外，与String类不同的是，StringBuilder和StringBuffer类的对象能够被多次修改，并且不产生新的未使用对象。每次对StringBuilder或StringBuffer的操作都会直接在其本身上进行，而不是生成新的对象。</p>
</li>
</ul>
<p>总的来说，如果你在单线程环境下进行字符串操作，并且对性能有较高要求，那么建议使用StringBuilder。如果你的应用场景需要在多线程环境下保证线程安全，那么可以考虑使用StringBuffer。</p>
<h1 id="Springboot如何获得IOC容器"><a href="#Springboot如何获得IOC容器" class="headerlink" title="Springboot如何获得IOC容器"></a>Springboot如何获得IOC容器</h1><p>在Springboot项目中，获取IOC容器的方式主要有两种。其中一种方法是在Springboot项目中都会存在一个名为SpringApplication的启动类，我们可以通过调用该类的run方法来启动IOC容器。另一种方式是直接从Spring容器中获取Bean实例。在某些特殊情况下，例如在拦截器中获取dao实例时，Bean需要实现某个功能，但该功能必须借助于Spring容器才能实现，此时就必须让该Bean先获取Spring容器。</p>
<h1 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h1><ul>
<li><p>依赖注入（Dependency Injection，简称DI）是一种设计模式，也是Spring框架的核心概念之一。其主要作用是去除Java类之间的依赖关系，实现松耦合，以便于开发和测试。具体来说，依赖注入就是不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p>
</li>
<li><p>此外，依赖注入是控制反转（Inversion of Control，简称IoC）思想的具体实现方式。控制反转是一种程序设计思想，而依赖注入则是其最典型的实践方法。在控制反转中，由第三方（通常称作IOC容器）来控制依赖，把依赖通过构造函数、属性或者工厂模式等方法，注入到类内，这样就极大程度的对类和其依赖进行了解耦。</p>
</li>
</ul>
<h1 id="为什么用security加jwt，为什么不用session"><a href="#为什么用security加jwt，为什么不用session" class="headerlink" title="为什么用security加jwt，为什么不用session"></a>为什么用security加jwt，为什么不用session</h1><ol>
<li>扩展性：Cookie和Session是基于HTTP协议的，随着Web技术的不断发展，如WebSockets等技术的出现，HTTP协议已经无法满足一些复杂的业务需求。新的技术，如Token、JWT等，可以更安全地存储用户信息，并克服了传统技术的一些缺点。</li>
<li>管理方式：JWT理论上用于无状态的请求，其用户管理也只是依赖本身而已。在它的payload中加入过期时间，无需增加额外的管理，只有自动过期的方式。而Session因为存储在服务器端，因此其管理方案就有很多，而且大多都很成熟。</li>
<li>跨平台：JWT可以实现跨平台使用，这是因为它的认证信息是存储在客户端的，而不是像Session一样存储在服务器端。</li>
<li>无状态：与Session不同，JWT不需要在服务器端存储状态信息。这降低了服务器的压力，并提高了系统的可扩展性。</li>
<li>安全性：JWT可以将用户信息加密后存储在客户端，提高了安全性。如果需要访问敏感信息，只需要解密部分数据即可，而不需要像Session一样将整个用户信息暴露给客户端。</li>
</ol>
<ul>
<li>传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。当用户访问应用服务，每个应用服务都会去服务器查看session信息，如果session中没有该用户则说明用户没有登录，此时就会重新认证，而解决这个问题的方法是Session复制、Session黏贴。</li>
<li>如果是基于令牌技术在分布式系统中实现认证则服务端不用存储session，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。</li>
</ul>
<h1 id="RBAC权限模型介绍，权限怎么分配的"><a href="#RBAC权限模型介绍，权限怎么分配的" class="headerlink" title="RBAC权限模型介绍，权限怎么分配的"></a>RBAC权限模型介绍，权限怎么分配的</h1><p>基于角色的访问控制（Role-Based Access Control）{<em>系统可扩展性差。</em>}</p>
<p>基于资源的访问控制（Resource-Based Access Control）{<em>系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，系统可扩展性强。</em>}</p>
<h1 id="redis都有哪些数据类型"><a href="#redis都有哪些数据类型" class="headerlink" title="redis都有哪些数据类型"></a>redis都有哪些数据类型</h1><ul>
<li><p>Redis支持的主要数据类型有五种：string（字符串），hash（哈希），list（列表），set（集合）和zset (sorted set：有序集合)。其中，string 是 Redis 最基本的类型，每个 key 对应一个 value，并且 string 类型是二进制安全的，意味着它可以包含任何数据，如jpg图片或序列化的对象。这种数据类型的值最大能存储 512MB。</p>
</li>
<li><p>在实际业务场景中，string 类型常用来缓存结构体信息，也经常被用来存储用户的session信息、缓存静态文件等。而 hash 类型则是一种键值对的集合，适用于存储对象。list 是一个简单的字符串列表，按插入顺序排序，适用于消息队列、关注列表等场景。set 是一个无序且不重复的字符串集合，适用于抽奖、社交标签等功能。zset（有序集合）和 set 类似，但每个元素都会关联一个 double 类型的分数，用于排序，适用于排行榜等场景。</p>
</li>
</ul>
<h1 id="java-NIO"><a href="#java-NIO" class="headerlink" title="java NIO"></a>java NIO</h1><ol>
<li><h2 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h2><p>NIO（New I&#x2F;O）是Java提供的一种非阻塞I&#x2F;O模型，它在JDK 1.4中引入。与传统的I&#x2F;O模型相比，NIO提供了更高效、更灵活的I&#x2F;O操作方式。</p>
</li>
<li><h2 id="为什么需要NIO"><a href="#为什么需要NIO" class="headerlink" title="为什么需要NIO?"></a><strong>为什么需要NIO?</strong></h2><p>传统的I&#x2F;O模型使用阻塞式I&#x2F;O，在进行读写操作时会导致线程被阻塞，直到数据准备好或者写入完成。这种模型对于并发处理能力较弱，当有大量连接同时请求时，每个连接都需要一个独立的线程来处理，造成资源浪费和性能下降。</p>
<p>而NIO采用了事件驱动的方式，通过Selector轮询注册的通道，只有在通道真正有读写事件发生时才会进行处理，避免了线程被阻塞的情况，提高了系统的并发处理能力。</p>
</li>
<li><p><strong>NIO的实现原理?</strong></p>
<p>NIO的核心组件包括：Channel、Buffer和Selector。</p>
<p>Channel: 类似于传统I&#x2F;O中的流，可以通过Channel进行数据的读取和写入。常见的Channel类型有SocketChannel、ServerSocketChannel、FileChannel等。<br>Buffer: 缓冲区，用于存储数据。在NIO中，所有的数据都是通过Buffer进行读写的。常见的Buffer类型有ByteBuffer、CharBuffer、IntBuffer等。<br>Selector: 选择器，用于监听多个Channel的事件。通过Selector可以实现单线程处理多个通道的读写操作。<br>NIO的工作原理如下：</p>
<ul>
<li>创建一个Selector，并将其注册到需要监听的Channel上。</li>
<li>当有数据准备好时，Selector会轮询已注册的Channel，发现有事件发生的Channel后进行处理。</li>
<li>根据不同的事件类型（读、写、连接、接收），使用对应的方法进行处理。</li>
</ul>
</li>
<li><h2 id="NIO的优点"><a href="#NIO的优点" class="headerlink" title="NIO的优点"></a>NIO的优点</h2><p>高并发性：NIO采用了事件驱动的方式，可以使用单线程处理多个通道的读写操作，提高系统的并发处理能力。<br>非阻塞式I&#x2F;O：NIO模型中的通道是非阻塞的，不会因为某个通道的读写操作而导致线程被阻塞，提高了系统的响应速度和吞吐量。<br>内存管理优化：NIO使用了直接内存缓冲区，可以减少数据在Java堆和操作系统之间的拷贝次数，提高了I&#x2F;O性能。</p>
</li>
<li><h2 id="NIO的缺点"><a href="#NIO的缺点" class="headerlink" title="NIO的缺点"></a>NIO的缺点</h2><p>复杂性较高：相比传统的阻塞式I&#x2F;O模型，NIO的编程模型更加复杂，需要处理事件驱动、多路复用等概念。<br>对编程人员要求较高：由于NIO的复杂性，对编程人员的技术要求较高，需要熟悉NIO相关的API和底层原理。</p>
</li>
<li><h2 id="NIO的使用注意事项"><a href="#NIO的使用注意事项" class="headerlink" title="NIO的使用注意事项"></a>NIO的使用注意事项</h2><p>需要合理设置缓冲区大小：过小的缓冲区可能导致频繁的读写操作，影响性能；过大的缓冲区可能造成资源浪费。<br>注意正确释放资源：在使用完Channel和Buffer后，需要及时关闭并释放资源，避免出现资源泄露问题。<br>谨慎处理异常情况：NIO中的异常处理相对复杂，需要仔细处理各种异常情况，以保证程序的稳定性和可靠性。</p>
</li>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NIO是一种非阻塞I&#x2F;O模型，通过事件驱动和选择器机制实现高效的I&#x2F;O操作。它具有高并发性、非阻塞式I&#x2F;O和内存管理优化等优点，但也存在复杂性较高和对编程人员要求较高的缺点。在使用NIO时需要注意合理设置缓冲区大小、正确释放资源和谨慎处理异常情况。</p>
</li>
</ol>
<h1 id="java的面向对象都有哪些"><a href="#java的面向对象都有哪些" class="headerlink" title="java的面向对象都有哪些"></a>java的面向对象都有哪些</h1><p>Java面向对象编程是一种编程范式，它包括三大基本特征：封装、继承和多态。封装是指将数据和方法绑定在一起，形成一个类，从而隐藏了类的实现细节；继承是指从已有的类派生出新的类，新的类继承了原有类的属性和方法，并可以添加新的属性和方法；多态是指同一种类型的对象在不同的情况下具有不同的行为。</p>
<p>在Java中，面向对象的核心概念包括对象、类和实例。对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类是一个模板，它描述一类对象的行为和状态。每个对象都是某个类的实例，它们可以拥有相同的属性和方法。</p>
<p>另外，抽象、接口、方法和重载也是Java面向对象编程的重要概念。抽象是指将一类对象的共同特征总结出来构造类的过程，它忽略了对象之间的差异。接口定义了一种规范，规定了实现此接口的类必须提供哪些方法。方法是一段具有特定功能的代码块，可以接受参数并返回结果。重载是指在一个类中允许存在一个以上同名的方法，但这些方法的参数数量或类型必须不同。</p>
<h1 id="java的容器都有哪些"><a href="#java的容器都有哪些" class="headerlink" title="java的容器都有哪些"></a>java的容器都有哪些</h1><p>Java的容器主要包括以下几种类型：</p>
<ol>
<li>数组(Array)：这是Java最基础的容器类型，它能够容纳固定数量的对象。</li>
<li>集合(Collection)：这是一种动态的容器类型，可以容纳任意数量的对象。其中一些常用的集合类型包括List、Set和Queue。例如，List是一个有序的集合，允许元素的重复，并提供了诸如add()添加元素、remove()移除元素、获取表的大小size()、get()获取元素等方法；而Set是一个不允许元素重复且不保持顺序的集合。</li>
<li>Map：这是一种关联数组，存储的是键值对（key-value pairs）。每个键都与一个值相关联，这样可以方便地通过键查找值。</li>
<li>字符串(StringBuilder和StringBuffer)：这两种类型的对象主要用于处理和操作字符串。其中，StringBuilder类的对象用于处理长度可变的字符串，而StringBuffer类的对象则用于处理内容不可变的字符串。</li>
</ol>
<h1 id="什么是java反射"><a href="#什么是java反射" class="headerlink" title="什么是java反射"></a>什么是java反射</h1><p>Java反射是一种强大的编程技术，它允许运行中的程序访问、检查和修改一个类的属性和方法。具体来说，反射使程序员能够在运行时知道任意一个类的所有属性和方法，无论这个类是在什么时候加载的。此外，反射还使得对于任意一个对象，都能够调用它的任意方法和属性，甚至可以在运行时改变它的属性。</p>
<p>Java反射机制的核心在于程序运行时动态加载类以及获取该类的详细信息，包括类的属性和方法。这一过程依赖于JVM得到的Class对象，通过这个对象，程序能够获取到类的各种信息，并进行反编译等操作。</p>
<p>Java反射机制提供了许多功能，包括但不限于：判断运行时任意对象所属的类；创建运行时任意类的对象；判断运行时任意类所具有的成员变量和方法；以及在运行时调用任意对象的方法。这些特性使得Java被视为具有动态性质的一种语言。</p>
<p>总的来说，Java反射技术让程序在运行时可以获取类的信息、操作类对象、动态调用方法、创建类实例等，从而在很大程度上增强了程序的灵活性和可扩展性。</p>
<h1 id="springMVC有哪些组件"><a href="#springMVC有哪些组件" class="headerlink" title="springMVC有哪些组件"></a>springMVC有哪些组件</h1><p>SpringMVC的组件有以下几种：前端控制器（DispatcherServlet），处理器映射器（HandlerMapping），处理器适配器（HandlerAdapter），拦截器（HandlerInterceptor），语言环境处理器（LocaleResolver）等  。其中，前端控制器（DispatcherServlet）是请求的入口，处理器映射器（HandlerMapping）负责让请求和控制器建立一一对应的关联，处理器适配器（HandlerAdapter）运用了设计模式中的适配器模式，统一调用不同的Handler，拦截器（HandlerInterceptor）可以在请求处理之前或之后进行一些操作，语言环境处理器（LocaleResolver）则用于解析客户端请求的语言环境。</p>
<h1 id="springboot的优势"><a href="#springboot的优势" class="headerlink" title="springboot的优势"></a>springboot的优势</h1><p>Spring Boot是Spring框架的一种扩展，其优势主要体现在以下几个方面：首先，Spring Boot可以快速构建独立的Spring应用。它依靠大量的注解实现自动化配置，开发者只需添加相应的场景依赖，Spring Boot就会自动进行配置，从而无需额外手动添加配置就可以快速构建出一个独立的Spring应用。其次，Spring Boot可以直接嵌入Tomcat、Jetty和Undertow服务器，无需部署WAR文件。此外，Spring Boot还提供了诸如自动starter依赖、自动配置Spring以及第三方功能、生产级别的监控、健康检查以及外部优化配置等一系列特性，极大地简化了开发、部署效率。最后，Spring Boot与云计算的天然集成，使其更适应现代化的软件开发和部署。</p>
<ul>
<li><p>简化依赖</p>
<p>比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p>
</li>
</ul>
<p><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code><br>    <code>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</code><br><code>&lt;/dependency&gt;</code><br>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p>
<p><code>&lt;!-- .....省略其他依赖 --&gt;</code><br><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>    <code>&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</code><br>    <code>&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</code><br>    <code>&lt;scope&gt;compile&lt;/scope&gt;</code><br><code>&lt;/dependency&gt;</code><br><code>&lt;dependency&gt;</code><br>    <code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;</code><br>    <code>&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</code><br>    <code>&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</code><br>    <code>&lt;scope&gt;compile&lt;/scope&gt;</code><br><code>&lt;/dependency&gt;</code><br>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p>
<ul>
<li><p>简化配置</p>
<p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p>
</li>
</ul>
<p>我新建一个类，但是我不用 @Service注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要@Configuration 和@Bean两个注解即可，如下：</p>
<p><code>public class TestService &#123;</code><br>    <code>public String sayHello () &#123;</code><br>        <code>return &quot;Hello Spring Boot!&quot;;</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p><code>import org.springframework.context.annotation.Bean;</code><br><code>import org.springframework.context.annotation.Configuration;</code></p>
<p><code>@Configuration</code><br><code>public class JavaConfig &#123;</code><br>    <code>@Bean</code><br>    <code>public TestService getTestService() &#123;</code><br>        <code>return new TestService();</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p>@Configuration表示该类是个配置类，@Bean表示该方法返回一个 Bean。这样就把TestService作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用@Resource注解注入进来即可使用，非常方便。</p>
<p><code>@Resource private TestService testService;</code></p>
<p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p>
<ul>
<li><p>简化部署</p>
<p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。</p>
</li>
</ul>
<p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p>
<ul>
<li><p>简化监控</p>
<p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p>
<h1 id="springboot的核心注解文件"><a href="#springboot的核心注解文件" class="headerlink" title="springboot的核心注解文件"></a>springboot的核心注解文件</h1></li>
</ul>
<p>Spring Boot的核心注解是@SpringBootApplication，这个注解通常用在启动类上，主要的功能是让Spring Boot自动为程序进行必要的配置。它主要由以下三个注解组成：@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。</p>
<ul>
<li>@SpringBootConfiguration是一个组合注解，其中包含了@Configuration，这使得它可以替代applicationContext.xml配置文件，所有能在配置文件里完成的事情都可以通过这个注解所在的类来进行注册。</li>
<li>@EnableAutoConfiguration是用来打开自动配置的功能，可以根据classpath下的jar包自动配置，例如数据源自动配置等。如果需要关闭某个自动配置的选项，可以使用类似以下的代码：@SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan是Spring框架中的一个注解，它会扫描指定包路径下的所有类，并将这些类注册为bean，这样就可以在其他地方使用这些bean了。</li>
</ul>
<p>此外，Spring Boot还提供了两个全局配置文件：application.properties和application.yaml，这两个文件可以对一些默认配置值进行修改。这两个文件一般存放在项目的src&#x2F;main&#x2F;resources目录下。</p>
<h1 id="什么是spring-ioc"><a href="#什么是spring-ioc" class="headerlink" title="什么是spring ioc"></a>什么是spring ioc</h1><p>Spring IOC是一种让服务消费者不直接依赖于服务提供者的组件设计方式，是一种减少类与类之间依赖的设计原则。它将对象的创建权力反转给Spring框架，通过在IOC容器中创建对象，实现了对象之间的解耦。在传统的Java开发中，一个类想要使用另一个类的方法，就必须在这个类中创建这个类的对象，这样可能会导致程序出现耦合性问题。而Spring IOC通过将对象的创建和管理交给Spring容器，使得对象之间的依赖关系由容器来维护，从而降低了程序的耦合性，提高了程序的可维护性和可扩展性。</p>
<h1 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h1><p>CAS是Compare and Swap的缩写，即比较并交换。它是一种多线程同步的算法，用于实现多线程环境下的原子操作。在CAS中，操作数值的时候，会先比较当前内存中的值是否与期望值相等，如果相等，则将新值写入内存；否则，不做任何操作。CAS操作是一种乐观锁，它不需要加锁，因此可以提高并发性能。CAS常用于实现线程安全的数据结构，如原子类和自旋锁等。</p>
<h1 id="什么是双亲委派模型-优点是什么"><a href="#什么是双亲委派模型-优点是什么" class="headerlink" title="什么是双亲委派模型 优点是什么"></a>什么是双亲委派模型 优点是什么</h1><p>双亲委派模型是Java中的一种类加载机制，它指的是类加载器在加载一个类时，先将该请求委派给父类加载器去完成，如果父类加载器还存在父类加载器，则继续向上委派，直到委派到最顶层的启动类加载器为止。如果父类加载器无法完成类的加载请求，子加载器才会尝试自己去加载。这种机制可以避免重复加载，保证了Java程序的稳定性和安全性。</p>
<p>双亲委派模型的优点主要有两个：</p>
<ol>
<li>避免类的重复加载：由于类加载器在加载类时会先委派给父类加载器，因此可以避免同一个类被多次加载，从而节省了内存空间。</li>
<li>提高安全性：由于父类加载器在委派给子类加载器时会先检查该类是否已经被加载过，如果已经被加载过，则直接返回已经加载的类，从而避免了恶意类的加载，提高了Java程序的安全性。</li>
</ol>
<h1 id="一个对象垃圾回收的全过程"><a href="#一个对象垃圾回收的全过程" class="headerlink" title="一个对象垃圾回收的全过程"></a>一个对象垃圾回收的全过程</h1><p>一个对象从加载到JVM再到被GC清除，它的过程可以分为几个阶段：类加载、对象实例化、对象使用和垃圾回收。新创建的对象首先会被分配到Eden区。随着程序的运行，Eden区可能会满或者快满，这时就会进行一次Minor GC，也就是清理过程。在这个过程中，不被引用的对象会被直接清除掉；仍然有引用的对象，但如果它们的存在时间较长，则会被移动到S0区。</p>
<p>当Eden区再次快满的时候，会再进行一次清理，这次清理会涉及到Eden区和Survivor A区。存活的对象会被放入Survivor A区，而Eden区则被清空。</p>
<p>这个过程并不是一次性的，而是会在JVM运行时持续发生。每次垃圾回收后，Eden区会继续提供堆内存供新的对象存放。这就是一个对象从创建到被垃圾回收的全过程。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/01/%E3%80%90java%E9%9D%A2%E7%BB%8F%E3%80%91/">http://example.com/2023/12/01/%E3%80%90java%E9%9D%A2%E7%BB%8F%E3%80%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/11/30/test-01/" title="test-01"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">test-01</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Jasonhao1/Jasonhao1.github.io"><i class="fab fa-github"></i><span>Follow Lzq</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9Fspring%E6%94%AF%E6%8C%81%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9F%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">什么叫事务传播行为？spring支持几种事务传播行为？都是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%A4%9A%E6%80%81"><span class="toc-number">2.</span> <span class="toc-text">什么是java多态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringAOP-%E4%BB%A3%E7%90%86%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">SpringAOP 代理中有几种方式，分别是什么，有什么特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFASM%E6%A1%86%E6%9E%B6"><span class="toc-number">4.</span> <span class="toc-text">什么是ASM框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%97%B6%EF%BC%8C%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%BA%E7%A9%BA%E6%97%B6%E4%B8%8D%E4%BF%AE%E6%94%B9%EF%BC%8C%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99sql%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%8A%A8%E6%80%81sql%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">mybatis修改一个字段时，部分字段为空时不修改，怎么编写sql语句（动态sql）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86jdk%E5%92%8Ccglib%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">spring两种代理jdk和cglib的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp-ip-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">tcp ip 三次握手四次挥手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E5%92%8Chttps%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">http和https什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86"><span class="toc-number">9.</span> <span class="toc-text">对称性加密和非对称性加密</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">cookie和session的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E5%95%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%87%92%E6%B1%89%E8%A6%81%E5%8F%8C%E9%87%8D%E5%88%A4%E6%96%AD"><span class="toc-number">11.</span> <span class="toc-text">实现单例对象有几种方式，这些方式优缺点是啥，为什么懒汉要双重判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AAArrayList%E7%9A%84%E5%B9%B6%E9%9B%86%E3%80%81%E4%BA%A4%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86"><span class="toc-number">12.</span> <span class="toc-text">怎么计算两个ArrayList的并集、交集、差集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9-%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84List"><span class="toc-number">13.</span> <span class="toc-text">ArrayList和LinkedList区别，优缺点 是不是线程安全，怎么使用一个线程安全的的List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#currentHashMap-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1-7%E5%92%8C1-8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">currentHashMap 怎么保证线程安全 1.7和1.8有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">15.</span> <span class="toc-text">怎么理解哈希冲突</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">16.</span> <span class="toc-text">怎样理解序列化和反序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SrtingBuffer%E5%92%8CStringBuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">SrtingBuffer和StringBuilder区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Springboot%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">18.</span> <span class="toc-text">Springboot如何获得IOC容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">19.</span> <span class="toc-text">什么是依赖注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8security%E5%8A%A0jwt%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8session"><span class="toc-number">20.</span> <span class="toc-text">为什么用security加jwt，为什么不用session</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RBAC%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%9A%84"><span class="toc-number">21.</span> <span class="toc-text">RBAC权限模型介绍，权限怎么分配的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">22.</span> <span class="toc-text">redis都有哪些数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-NIO"><span class="toc-number">23.</span> <span class="toc-text">java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFNIO"><span class="toc-number">23.1.</span> <span class="toc-text">什么是NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81NIO"><span class="toc-number">23.2.</span> <span class="toc-text">为什么需要NIO?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">23.3.</span> <span class="toc-text">NIO的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">23.4.</span> <span class="toc-text">NIO的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">23.5.</span> <span class="toc-text">NIO的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">23.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">24.</span> <span class="toc-text">java的面向对象都有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E7%9A%84%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">25.</span> <span class="toc-text">java的容器都有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%8F%8D%E5%B0%84"><span class="toc-number">26.</span> <span class="toc-text">什么是java反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springMVC%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-number">27.</span> <span class="toc-text">springMVC有哪些组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">28.</span> <span class="toc-text">springboot的优势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%96%87%E4%BB%B6"><span class="toc-number">29.</span> <span class="toc-text">springboot的核心注解文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-ioc"><span class="toc-number">30.</span> <span class="toc-text">什么是spring ioc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-number">31.</span> <span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B-%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">32.</span> <span class="toc-text">什么是双亲委派模型 优点是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">33.</span> <span class="toc-text">一个对象垃圾回收的全过程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/01/%E3%80%90java%E9%9D%A2%E7%BB%8F%E3%80%91/" title="Java面经">Java面经</a><time datetime="2023-12-01T01:02:48.000Z" title="发表于 2023-12-01 09:02:48">2023-12-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/test-01/" title="test-01">test-01</a><time datetime="2023-11-30T02:47:34.000Z" title="发表于 2023-11-30 10:47:34">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/test/" title="test">test</a><time datetime="2023-11-30T02:12:39.000Z" title="发表于 2023-11-30 10:12:39">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/hello-world/" title="Hello World">Hello World</a><time datetime="2023-11-30T01:59:03.499Z" title="发表于 2023-11-30 09:59:03">2023-11-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>